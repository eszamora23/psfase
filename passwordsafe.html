<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="Content-Security-Policy" content="default-src 'none'; script-src 'unsafe-inline'; style-src 'unsafe-inline'; img-src data:;">
<title>Password Safe</title>
<style>
/* ---- Reset & Base ---- */
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Inter', sans-serif;
  background: #f1f5f9; color: #1e293b; min-height: 100vh;
  line-height: 1.5; -webkit-font-smoothing: antialiased;
}
.hidden { display: none !important; }

/* ---- Lock / Open Screen ---- */
#screen-open {
  display: flex; align-items: center; justify-content: center;
  min-height: 100vh; padding: 24px;
  background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%);
}
.open-card {
  background: #fff; border-radius: 20px; padding: 48px 44px;
  width: 100%; max-width: 460px;
  box-shadow: 0 20px 60px rgba(0,0,0,.25), 0 1px 3px rgba(0,0,0,.06);
}
.open-card h1 {
  font-size: 28px; font-weight: 800; margin-bottom: 4px; color: #0f172a;
  display: flex; align-items: center; gap: 10px;
}
.open-card h1 svg { color: #6366f1; flex-shrink: 0; }
.open-card .subtitle { color: #64748b; font-size: 13px; margin-bottom: 32px; }
.version-tag { color: #cbd5e1; font-size: 11px; font-weight: 500; }

/* ---- Drop zone ---- */
.drop-zone {
  border: 2px dashed #cbd5e1; border-radius: 14px; padding: 36px 20px;
  text-align: center; cursor: pointer; transition: all .25s ease;
  background: #f8fafc; margin-bottom: 24px; position: relative;
}
.drop-zone:hover { border-color: #6366f1; background: #eef2ff; }
.drop-zone.drag-over {
  border-color: #6366f1; background: #eef2ff;
  box-shadow: 0 0 0 4px rgba(99,102,241,.15);
  transform: scale(1.01);
}
.drop-zone svg { margin-bottom: 10px; color: #94a3b8; }
.drop-zone p { font-size: 14px; color: #475569; font-weight: 500; }
.drop-zone .hint { font-size: 12px; color: #94a3b8; margin-top: 4px; }

/* ---- File badge ---- */
.file-badge {
  display: inline-flex; align-items: center; gap: 6px;
  background: #ecfdf5; color: #059669; border: 1px solid #a7f3d0;
  border-radius: 8px; padding: 6px 14px; font-size: 13px; font-weight: 600;
  margin-bottom: 20px; animation: badgeIn .3s ease;
}
@keyframes badgeIn {
  from { opacity: 0; transform: translateY(-4px); }
  to { opacity: 1; transform: translateY(0); }
}

/* ---- Forms ---- */
.form-group { margin-bottom: 20px; }
.form-group label {
  display: block; font-size: 13px; font-weight: 600;
  color: #374151; margin-bottom: 6px;
}
input[type=password], input[type=text], input[type=search], input[type=number], textarea {
  width: 100%; padding: 10px 14px; border: 1px solid #d1d5db;
  border-radius: 10px; font-size: 14px; font-family: inherit;
  outline: none; transition: border-color .2s, box-shadow .2s;
  background: #fff; color: #1e293b;
}
input[type=password]:focus, input[type=text]:focus, input[type=search]:focus,
input[type=number]:focus, textarea:focus {
  border-color: #6366f1; box-shadow: 0 0 0 3px rgba(99,102,241,.1);
}
input[readonly], textarea[readonly] {
  background: #f8fafc; border-color: #e2e8f0; color: #475569; cursor: default;
}
textarea { resize: vertical; min-height: 80px; }

/* ---- Buttons ---- */
.btn {
  padding: 10px 20px; border: none; border-radius: 10px;
  font-size: 14px; font-weight: 600; cursor: pointer;
  transition: all .2s ease; display: inline-flex;
  align-items: center; justify-content: center; gap: 6px;
}
.btn:disabled { opacity: .45; cursor: not-allowed; }
.btn-primary { background: #6366f1; color: #fff; width: 100%; }
.btn-primary:hover:not(:disabled) { background: #4f46e5; box-shadow: 0 4px 12px rgba(99,102,241,.35); }
.btn-secondary { background: #e2e8f0; color: #374151; }
.btn-secondary:hover { background: #cbd5e1; }
.btn-danger { background: #ef4444; color: #fff; }
.btn-danger:hover { background: #dc2626; }
.btn-sm { padding: 6px 14px; font-size: 12px; border-radius: 8px; }
.btn-ghost { background: transparent; color: #6366f1; border: 1px solid #e2e8f0; }
.btn-ghost:hover { background: #eef2ff; border-color: #6366f1; }
.btn-row { display: flex; gap: 10px; margin-top: 20px; }
.btn-row .btn { flex: 1; }

/* ---- Status messages ---- */
#status { margin-top: 16px; font-size: 13px; text-align: center; min-height: 20px; font-weight: 500; }
.status-error { color: #ef4444; }
.status-ok { color: #22c55e; }
.status-info { color: #6366f1; }

/* ---- Vault Screen (sidebar + main layout) ---- */
#screen-vault { display: flex; height: 100vh; }

/* ---- Sidebar ---- */
.sidebar {
  width: 300px; background: #0f172a; color: #e2e8f0;
  display: flex; flex-direction: column; flex-shrink: 0;
  border-right: 1px solid #1e293b;
}
.sidebar-header {
  padding: 20px 16px 14px; border-bottom: 1px solid #1e293b;
  display: flex; align-items: center; gap: 10px;
}
.sidebar-header svg { color: #6366f1; flex-shrink: 0; }
.vault-title {
  font-weight: 700; font-size: 15px; color: #f1f5f9;
  flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
.count-badge {
  background: #334155; color: #94a3b8; font-size: 11px; font-weight: 700;
  padding: 2px 8px; border-radius: 10px; flex-shrink: 0;
}

/* ---- Sidebar search ---- */
.sidebar-search { padding: 12px 16px; position: relative; }
.sidebar-search svg {
  position: absolute; left: 28px; top: 50%; transform: translateY(-50%);
  color: #64748b; pointer-events: none;
}
.sidebar-search input {
  width: 100%; padding: 8px 12px 8px 36px; border: 1px solid #334155;
  border-radius: 8px; background: #1e293b; color: #e2e8f0;
  font-size: 13px; outline: none; transition: border-color .2s;
}
.sidebar-search input::placeholder { color: #64748b; }
.sidebar-search input:focus { border-color: #6366f1; }

/* ---- Entry list ---- */
.entry-list { flex: 1; overflow-y: auto; padding: 4px 0; }
.entry-list::-webkit-scrollbar { width: 6px; }
.entry-list::-webkit-scrollbar-track { background: transparent; }
.entry-list::-webkit-scrollbar-thumb { background: #334155; border-radius: 3px; }
.entry-list::-webkit-scrollbar-thumb:hover { background: #475569; }

.group-header {
  padding: 12px 16px 6px; font-size: 10px; font-weight: 700;
  text-transform: uppercase; letter-spacing: .08em;
  color: #64748b; position: sticky; top: 0;
  background: #0f172a; z-index: 2;
}
.entry-item {
  display: flex; align-items: center; gap: 12px;
  padding: 10px 16px; cursor: pointer; transition: all .15s;
  border-left: 3px solid transparent; margin: 1px 0;
}
.entry-item:hover { background: #1e293b; }
.entry-item.active { background: #1e293b; border-left-color: #6366f1; }

/* ---- Entry avatar (colored circle with initials) ---- */
.entry-avatar {
  width: 36px; height: 36px; border-radius: 50%; flex-shrink: 0;
  display: flex; align-items: center; justify-content: center;
  font-size: 13px; font-weight: 700; color: #fff;
  text-transform: uppercase; letter-spacing: .02em;
}
.entry-info { min-width: 0; flex: 1; }
.entry-title {
  font-weight: 600; font-size: 13px; color: #f1f5f9;
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
.entry-user {
  font-size: 12px; color: #64748b; margin-top: 1px;
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}

/* ---- Sidebar footer ---- */
.sidebar-footer {
  padding: 12px 16px; border-top: 1px solid #1e293b;
  display: flex; gap: 8px;
}
.sidebar-footer button {
  flex: 1; padding: 8px 0; border: none; border-radius: 8px;
  font-size: 12px; font-weight: 600; cursor: pointer;
  transition: all .2s; display: flex; align-items: center;
  justify-content: center; gap: 5px;
}
.btn-add { background: #6366f1; color: #fff; }
.btn-add:hover { background: #4f46e5; }
.btn-save { background: #334155; color: #e2e8f0; }
.btn-save:hover { background: #475569; }
.btn-lock { background: #334155; color: #f87171; }
.btn-lock:hover { background: #475569; }

/* ---- Main content area ---- */
.main-content {
  flex: 1; overflow-y: auto; padding: 32px 40px; background: #f1f5f9;
  display: flex; flex-direction: column;
}
.detail-card {
  background: #fff; border-radius: 16px; padding: 32px;
  max-width: 680px; width: 100%;
  box-shadow: 0 1px 3px rgba(0,0,0,.04), 0 4px 16px rgba(0,0,0,.04);
}
.detail-header {
  display: flex; align-items: center; gap: 16px; margin-bottom: 28px;
  padding-bottom: 20px; border-bottom: 1px solid #f1f5f9;
}
.detail-avatar {
  width: 48px; height: 48px; border-radius: 50%; flex-shrink: 0;
  display: flex; align-items: center; justify-content: center;
  font-size: 18px; font-weight: 700; color: #fff; text-transform: uppercase;
}
.detail-header h2 { font-size: 20px; font-weight: 700; color: #0f172a; margin: 0; }
.detail-header .detail-group { font-size: 13px; color: #94a3b8; margin-top: 2px; }

/* ---- Detail fields ---- */
.field-row { margin-bottom: 18px; }
.field-row label {
  display: block; font-size: 11px; font-weight: 700;
  color: #64748b; margin-bottom: 5px; text-transform: uppercase;
  letter-spacing: .04em;
}
.field-value { display: flex; align-items: center; gap: 8px; }
.password-field { font-family: 'Courier New', 'Fira Code', monospace; letter-spacing: .5px; }

/* ---- Icon buttons ---- */
.btn-icon {
  background: none; border: 1px solid #e2e8f0; border-radius: 8px;
  padding: 7px 10px; cursor: pointer; font-size: 13px; color: #64748b;
  transition: all .15s; display: inline-flex; align-items: center; justify-content: center;
  flex-shrink: 0;
}
.btn-icon:hover { background: #eef2ff; border-color: #6366f1; color: #6366f1; }
.btn-icon svg { width: 16px; height: 16px; }

.detail-actions {
  display: flex; gap: 10px; margin-top: 28px; padding-top: 20px;
  border-top: 1px solid #f1f5f9;
}
.timestamp { font-size: 12px; color: #94a3b8; margin-top: 6px; }

/* ---- Empty state ---- */
.empty-state {
  display: flex; flex-direction: column; align-items: center;
  justify-content: center; flex: 1; color: #94a3b8; font-size: 15px;
  text-align: center; padding: 40px; min-height: 400px;
}
.empty-state svg { margin-bottom: 20px; opacity: .25; }
.empty-state .hint { font-size: 13px; color: #b0b8c4; margin-top: 10px; }
.empty-state kbd { margin: 0 2px; }

/* ---- Password Generator ---- */
.pw-gen {
  background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 12px;
  padding: 16px; margin-top: 12px;
}
.pw-gen-header {
  display: flex; align-items: center; justify-content: space-between;
  margin-bottom: 12px;
}
.pw-gen-header span { font-size: 12px; font-weight: 700; color: #64748b; text-transform: uppercase; }
.pw-gen-row { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; }
.pw-gen-output {
  flex: 1; font-family: 'Courier New', monospace; font-size: 14px;
  padding: 8px 12px; background: #fff; border: 1px solid #d1d5db;
  border-radius: 8px; color: #1e293b; letter-spacing: .5px;
}
.pw-gen-options {
  display: flex; flex-wrap: wrap; gap: 12px;
  font-size: 13px; color: #475569; margin-bottom: 10px;
}
.pw-gen-options label {
  display: flex; align-items: center; gap: 4px; cursor: pointer;
  user-select: none;
}
.pw-gen-options input[type=checkbox] { accent-color: #6366f1; }
.pw-len-row { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; }
.pw-len-row input[type=range] { flex: 1; accent-color: #6366f1; }
.pw-len-row span { font-size: 13px; font-weight: 600; color: #475569; min-width: 24px; }
.pw-strength { height: 6px; background: #e2e8f0; border-radius: 3px; overflow: hidden; margin-top: 8px; }
.pw-strength-bar {
  height: 100%; border-radius: 3px; transition: width .3s, background .3s;
}
.pw-strength-label { font-size: 11px; color: #94a3b8; margin-top: 4px; text-align: right; }

/* ---- Toast notifications ---- */
.toast {
  position: fixed; bottom: 24px; right: 24px; z-index: 200;
  background: #1e293b; color: #f1f5f9; padding: 12px 20px;
  border-radius: 10px; font-size: 13px; font-weight: 500;
  box-shadow: 0 4px 20px rgba(0,0,0,.25);
  animation: toastIn .3s ease;
  display: flex; align-items: center; gap: 8px;
}
.toast svg { flex-shrink: 0; }
@keyframes toastIn {
  from { opacity: 0; transform: translateY(12px) scale(.96); }
  to { opacity: 1; transform: translateY(0) scale(1); }
}

/* ---- Modal ---- */
.modal-overlay {
  position: fixed; inset: 0; z-index: 100;
  background: rgba(15,23,42,.5); backdrop-filter: blur(4px);
  display: flex; align-items: center; justify-content: center;
  animation: overlayIn .2s ease;
}
@keyframes overlayIn {
  from { opacity: 0; }
  to { opacity: 1; }
}
.modal {
  background: #fff; border-radius: 20px; padding: 32px;
  width: 90%; max-width: 440px;
  box-shadow: 0 20px 60px rgba(0,0,0,.25);
  animation: modalIn .25s ease;
}
@keyframes modalIn {
  from { opacity: 0; transform: scale(.92) translateY(8px); }
  to { opacity: 1; transform: scale(1) translateY(0); }
}
.modal h3 { margin-bottom: 16px; font-size: 18px; font-weight: 700; color: #0f172a; }

/* ---- Keyboard shortcut hints ---- */
kbd {
  display: inline-block; padding: 2px 7px; font-size: 11px;
  font-family: inherit; color: #64748b; background: #f1f5f9;
  border: 1px solid #d1d5db; border-radius: 5px;
  box-shadow: 0 1px 0 #d1d5db; line-height: 1.4;
}

/* ---- Shortcuts bar (bottom of sidebar) ---- */
.shortcut-hints {
  padding: 8px 16px; border-top: 1px solid #1e293b;
  display: flex; gap: 12px; justify-content: center;
  font-size: 10px; color: #475569;
}
.shortcut-hints span { display: flex; align-items: center; gap: 3px; }
.shortcut-hints kbd {
  background: #1e293b; border-color: #334155; color: #94a3b8;
  box-shadow: 0 1px 0 #334155; font-size: 10px; padding: 1px 5px;
}

/* ---- Modified indicator ---- */
.modified-dot {
  width: 8px; height: 8px; border-radius: 50%; background: #f59e0b;
  display: inline-block; margin-left: 6px;
  animation: pulse 2s ease-in-out infinite;
}
@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: .4; }
}
</style>
</head>
<body>

<!-- LOCK / OPEN SCREEN -->
<div id="screen-open">
<div class="open-card">
  <h1>
    <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>
    Password Safe
  </h1>
  <p class="subtitle">Local .psafe3 vault viewer &amp; editor <span class="version-tag">v7</span></p>

  <div id="file-badge" class="file-badge hidden">
    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>
    <span id="file-name-text"></span>
  </div>

  <div id="drop-zone" class="drop-zone">
    <input type="file" id="file-input" accept=".psafe3,.dat" style="position:absolute;inset:0;opacity:0;cursor:pointer;">
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
    <p>Drop your .psafe3 file here</p>
    <div class="hint">or click to browse</div>
  </div>

  <div class="form-group">
    <label>Master Password</label>
    <input type="password" id="master-password" placeholder="Enter master password" autocomplete="off">
  </div>
  <div class="btn-row">
    <button class="btn btn-primary" id="btn-open" disabled>
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 9.9-1"/></svg>
      Unlock
    </button>
    <button class="btn btn-secondary" id="btn-new">New Vault</button>
  </div>
  <div id="status"></div>
</div>
</div>

<!-- VAULT SCREEN -->
<div id="screen-vault" class="hidden">
  <div class="sidebar">
    <div class="sidebar-header">
      <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>
      <span id="vault-name" class="vault-title">Vault</span>
      <span id="modified-indicator" class="hidden"><span class="modified-dot"></span></span>
      <span id="entry-count" class="count-badge">0</span>
    </div>
    <div class="sidebar-search">
      <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>
      <input type="search" id="search-box" placeholder="Search entries... (Ctrl+F)">
    </div>
    <div class="entry-list" id="entry-list"></div>
    <div class="sidebar-footer">
      <button class="btn-add" id="btn-add" title="New entry (Ctrl+N)">
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
        New
      </button>
      <button class="btn-save" id="btn-save" title="Save vault (Ctrl+S)">
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>
        Save
      </button>
      <button class="btn-lock" id="btn-lock" title="Lock vault (Ctrl+L)">
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>
        Lock
      </button>
    </div>
    <div class="shortcut-hints">
      <span><kbd>Ctrl+N</kbd> New</span>
      <span><kbd>Ctrl+S</kbd> Save</span>
      <span><kbd>Ctrl+F</kbd> Search</span>
    </div>
  </div>
  <div class="main-content" id="entry-detail">
    <div class="empty-state">
      <svg xmlns="http://www.w3.org/2000/svg" width="56" height="56" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"/></svg>
      <div>Select an entry to view details</div>
      <div class="hint">or press <kbd>Ctrl</kbd>+<kbd>N</kbd> to create a new one</div>
    </div>
  </div>
</div>

<!-- MODAL (reusable) -->
<div id="modal-overlay" class="modal-overlay hidden">
<div class="modal" id="modal-content"></div>
</div>

<script>
'use strict';

// =====================================================================
// TWOFISH BLOCK CIPHER
// This is the full Twofish 256-bit cipher written from scratch in JS.
// No libraries, no WebAssembly, nothing external - just math and lookup
// tables. We need this because browsers don't support Twofish natively
// (Web Crypto only gives us AES), and Password Safe uses Twofish for
// everything. The implementation follows the original Twofish paper and
// matches the LibTomCrypt version used in the official Password Safe app.
// =====================================================================

const Q0 = new Uint8Array([
  0xA9,0x67,0xB3,0xE8,0x04,0xFD,0xA3,0x76,0x9A,0x92,0x80,0x78,0xE4,0xDD,0xD1,0x38,
  0x0D,0xC6,0x35,0x98,0x18,0xF7,0xEC,0x6C,0x43,0x75,0x37,0x26,0xFA,0x13,0x94,0x48,
  0xF2,0xD0,0x8B,0x30,0x84,0x54,0xDF,0x23,0x19,0x5B,0x3D,0x59,0xF3,0xAE,0xA2,0x82,
  0x63,0x01,0x83,0x2E,0xD9,0x51,0x9B,0x7C,0xA6,0xEB,0xA5,0xBE,0x16,0x0C,0xE3,0x61,
  0xC0,0x8C,0x3A,0xF5,0x73,0x2C,0x25,0x0B,0xBB,0x4E,0x89,0x6B,0x53,0x6A,0xB4,0xF1,
  0xE1,0xE6,0xBD,0x45,0xE2,0xF4,0xB6,0x66,0xCC,0x95,0x03,0x56,0xD4,0x1C,0x1E,0xD7,
  0xFB,0xC3,0x8E,0xB5,0xE9,0xCF,0xBF,0xBA,0xEA,0x77,0x39,0xAF,0x33,0xC9,0x62,0x71,
  0x81,0x79,0x09,0xAD,0x24,0xCD,0xF9,0xD8,0xE5,0xC5,0xB9,0x4D,0x44,0x08,0x86,0xE7,
  0xA1,0x1D,0xAA,0xED,0x06,0x70,0xB2,0xD2,0x41,0x7B,0xA0,0x11,0x31,0xC2,0x27,0x90,
  0x20,0xF6,0x60,0xFF,0x96,0x5C,0xB1,0xAB,0x9E,0x9C,0x52,0x1B,0x5F,0x93,0x0A,0xEF,
  0x91,0x85,0x49,0xEE,0x2D,0x4F,0x8F,0x3B,0x47,0x87,0x6D,0x46,0xD6,0x3E,0x69,0x64,
  0x2A,0xCE,0xCB,0x2F,0xFC,0x97,0x05,0x7A,0xAC,0x7F,0xD5,0x1A,0x4B,0x0E,0xA7,0x5A,
  0x28,0x14,0x3F,0x29,0x88,0x3C,0x4C,0x02,0xB8,0xDA,0xB0,0x17,0x55,0x1F,0x8A,0x7D,
  0x57,0xC7,0x8D,0x74,0xB7,0xC4,0x9F,0x72,0x7E,0x15,0x22,0x12,0x58,0x07,0x99,0x34,
  0x6E,0x50,0xDE,0x68,0x65,0xBC,0xDB,0xF8,0xC8,0xA8,0x2B,0x40,0xDC,0xFE,0x32,0xA4,
  0xCA,0x10,0x21,0xF0,0xD3,0x5D,0x0F,0x00,0x6F,0x9D,0x36,0x42,0x4A,0x5E,0xC1,0xE0
]);

const Q1 = new Uint8Array([
  0x75,0xF3,0xC6,0xF4,0xDB,0x7B,0xFB,0xC8,0x4A,0xD3,0xE6,0x6B,0x45,0x7D,0xE8,0x4B,
  0xD6,0x32,0xD8,0xFD,0x37,0x71,0xF1,0xE1,0x30,0x0F,0xF8,0x1B,0x87,0xFA,0x06,0x3F,
  0x5E,0xBA,0xAE,0x5B,0x8A,0x00,0xBC,0x9D,0x6D,0xC1,0xB1,0x0E,0x80,0x5D,0xD2,0xD5,
  0xA0,0x84,0x07,0x14,0xB5,0x90,0x2C,0xA3,0xB2,0x73,0x4C,0x54,0x92,0x74,0x36,0x51,
  0x38,0xB0,0xBD,0x5A,0xFC,0x60,0x62,0x96,0x6C,0x42,0xF7,0x10,0x7C,0x28,0x27,0x8C,
  0x13,0x95,0x9C,0xC7,0x24,0x46,0x3B,0x70,0xCA,0xE3,0x85,0xCB,0x11,0xD0,0x93,0xB8,
  0xA6,0x83,0x20,0xFF,0x9F,0x77,0xC3,0xCC,0x03,0x6F,0x08,0xBF,0x40,0xE7,0x2B,0xE2,
  0x79,0x0C,0xAA,0x82,0x41,0x3A,0xEA,0xB9,0xE4,0x9A,0xA4,0x97,0x7E,0xDA,0x7A,0x17,
  0x66,0x94,0xA1,0x1D,0x3D,0xF0,0xDE,0xB3,0x0B,0x72,0xA7,0x1C,0xEF,0xD1,0x53,0x3E,
  0x8F,0x33,0x26,0x5F,0xEC,0x76,0x2A,0x49,0x81,0x88,0xEE,0x21,0xC4,0x1A,0xEB,0xD9,
  0xC5,0x39,0x99,0xCD,0xAD,0x31,0x8B,0x01,0x18,0x23,0xDD,0x1F,0x4E,0x2D,0xF9,0x48,
  0x4F,0xF2,0x65,0x8E,0x78,0x5C,0x58,0x19,0x8D,0xE5,0x98,0x57,0x67,0x7F,0x05,0x64,
  0xAF,0x63,0xB6,0xFE,0xF5,0xB7,0x3C,0xA5,0xCE,0xE9,0x68,0x44,0xE0,0x4D,0x43,0x69,
  0x29,0x2E,0xAC,0x15,0x59,0xA8,0x0A,0x9E,0x6E,0x47,0xDF,0x34,0x35,0x6A,0xCF,0xDC,
  0x22,0xC9,0xC0,0x9B,0x89,0xD4,0xED,0xAB,0x12,0xA2,0x0D,0x52,0xBB,0x02,0x2F,0xA9,
  0xD7,0x61,0x1E,0xB4,0x50,0x04,0xF6,0xC2,0x16,0x25,0x86,0x56,0x55,0x09,0xBE,0x91
]);

// RS matrix (4x8) for the key schedule. Multiplies in GF(2^8) with poly 0x14D.
// This takes 8 key bytes and spits out 4 S-box bytes. It's how Twofish
// derives the key-dependent S-boxes that make it resistant to linear attacks.
const RS = [
  [0x01,0xA4,0x55,0x87,0x5A,0x58,0xDB,0x9E],
  [0xA4,0x56,0x82,0xF3,0x1E,0xC6,0x68,0xE5],
  [0x02,0xA1,0xFC,0xC1,0x47,0xAE,0x3D,0x19],
  [0xA4,0x55,0x87,0x5A,0x58,0xDB,0x9E,0x03]
];

// Galois field multiplication - the fancy math behind the cipher.
// 0x14D is the polynomial for RS (key schedule), 0x169 is for MDS (output mixing).
function gfMul14D(a, b) {
  let r = 0, aa = a;
  for (let i = 0; i < 8; i++) {
    if (b & (1 << i)) r ^= aa;
    const hi = aa & 0x80;
    aa = (aa << 1) & 0xFF;
    if (hi) aa ^= 0x4D;
  }
  return r;
}

// Same thing but for the MDS matrix (poly 0x169)
function gfMul169(a, b) {
  let r = 0, aa = a;
  for (let i = 0; i < 8; i++) {
    if (b & (1 << i)) r ^= aa;
    const hi = aa & 0x80;
    aa = (aa << 1) & 0xFF;
    if (hi) aa ^= 0x69;
  }
  return r;
}

// Pre-building the MDS lookup tables so we don't recalculate during encryption.
// MDS (Maximum Distance Separable) matrix:
// [0x01, 0xEF, 0x5B, 0x5B]
// [0x5B, 0xEF, 0xEF, 0x01]
// [0xEF, 0x5B, 0x01, 0xEF]
// [0xEF, 0x01, 0xEF, 0x5B]
const MDS0 = new Uint32Array(256);
const MDS1 = new Uint32Array(256);
const MDS2 = new Uint32Array(256);
const MDS3 = new Uint32Array(256);

for (let i = 0; i < 256; i++) {
  const m = (a, b) => gfMul169(a, b);
  MDS0[i] = ((m(0x01,i)) | (m(0x5B,i)<<8) | (m(0xEF,i)<<16) | (m(0xEF,i)<<24)) >>> 0;
  MDS1[i] = ((m(0xEF,i)) | (m(0xEF,i)<<8) | (m(0x5B,i)<<16) | (m(0x01,i)<<24)) >>> 0;
  MDS2[i] = ((m(0x5B,i)) | (m(0xEF,i)<<8) | (m(0x01,i)<<16) | (m(0xEF,i)<<24)) >>> 0;
  MDS3[i] = ((m(0x5B,i)) | (m(0x01,i)<<8) | (m(0xEF,i)<<16) | (m(0x5B,i)<<24)) >>> 0;
}

// Helpers for reading/writing little-endian 32-bit integers from byte arrays
function rU32(b, o) { return (b[o] | (b[o+1]<<8) | (b[o+2]<<16) | (b[o+3]<<24)) >>> 0; }
function wU32(b, o, v) { b[o]=v&0xFF; b[o+1]=(v>>>8)&0xFF; b[o+2]=(v>>>16)&0xFF; b[o+3]=(v>>>24)&0xFF; }

// Bitwise rotation helpers (standard crypto building blocks)
function ROL(x, n) { return ((x << n) | (x >>> (32 - n))) >>> 0; }
function ROR(x, n) { return ((x >>> n) | (x << (32 - n))) >>> 0; }

// RS matrix multiply: takes 8 key bytes and compresses them to 4 S-box key bytes
function rsRemix(src, off) {
  const out = new Uint8Array(4);
  for (let i = 0; i < 4; i++) {
    let v = 0;
    for (let j = 0; j < 8; j++) v ^= gfMul14D(RS[i][j], src[off + j]);
    out[i] = v;
  }
  return out;
}

// h function - the heart of Twofish's key schedule.
// It takes a 32-bit word and runs each byte through a chain of Q permutations
// and XOR operations with the key material, then finishes with MDS.
// We only use this for generating the 40 round subkeys (Me/Mo words).
// The actual encryption uses precomputed S-box tables instead (way faster).
//
// The Q-permutation ordering for 256-bit keys (each byte gets a different chain):
//   byte 0: q1 -> xor L3 -> q1 -> xor L2 -> q0 -> xor L1 -> q0 -> xor L0 -> q1 -> MDS
//   byte 1: q0 -> xor L3 -> q1 -> xor L2 -> q1 -> xor L1 -> q0 -> xor L0 -> q0 -> MDS
//   byte 2: q0 -> xor L3 -> q0 -> xor L2 -> q0 -> xor L1 -> q1 -> xor L0 -> q1 -> MDS
//   byte 3: q1 -> xor L3 -> q0 -> xor L2 -> q1 -> xor L1 -> q1 -> xor L0 -> q0 -> MDS
function hFunc(x, L) {
  let b0 = x & 0xFF, b1 = (x>>>8) & 0xFF, b2 = (x>>>16) & 0xFF, b3 = (x>>>24) & 0xFF;
  // Stage 1 (outermost, XOR with L[3])
  b0 = Q1[b0] ^ (L[3] & 0xFF);
  b1 = Q0[b1] ^ ((L[3]>>>8) & 0xFF);
  b2 = Q0[b2] ^ ((L[3]>>>16) & 0xFF);
  b3 = Q1[b3] ^ ((L[3]>>>24) & 0xFF);
  // Stage 2 (XOR with L[2])
  b0 = Q1[b0] ^ (L[2] & 0xFF);
  b1 = Q1[b1] ^ ((L[2]>>>8) & 0xFF);
  b2 = Q0[b2] ^ ((L[2]>>>16) & 0xFF);
  b3 = Q0[b3] ^ ((L[2]>>>24) & 0xFF);
  // Stage 3 (XOR with L[1])
  b0 = Q0[b0] ^ (L[1] & 0xFF);
  b1 = Q1[b1] ^ ((L[1]>>>8) & 0xFF);
  b2 = Q0[b2] ^ ((L[1]>>>16) & 0xFF);
  b3 = Q1[b3] ^ ((L[1]>>>24) & 0xFF);
  // Stage 4 (XOR with L[0])
  b0 = Q0[b0] ^ (L[0] & 0xFF);
  b1 = Q0[b1] ^ ((L[0]>>>8) & 0xFF);
  b2 = Q1[b2] ^ ((L[0]>>>16) & 0xFF);
  b3 = Q1[b3] ^ ((L[0]>>>24) & 0xFF);
  // Final q (no XOR)
  b0 = Q1[b0]; b1 = Q0[b1]; b2 = Q1[b2]; b3 = Q0[b3];
  // MDS
  return (MDS0[b0] ^ MDS1[b1] ^ MDS2[b2] ^ MDS3[b3]) >>> 0;
}

// Set up Twofish for a given 256-bit key.
// This does all the heavy lifting upfront: derives S-box keys, generates 40 subkeys,
// and builds the 4 key-dependent S-box lookup tables. After this, encryption
// and decryption are just table lookups and XORs - no key material recomputation.
function twofishInit(key) {
  // Split the 32-byte key into even words (Me) and odd words (Mo)
  const Me = [rU32(key,0), rU32(key,8), rU32(key,16), rU32(key,24)];
  const Mo = [rU32(key,4), rU32(key,12), rU32(key,20), rU32(key,28)];

  // Run each 8-byte chunk of the key through the RS matrix to get the S-box keys
  const s0 = rsRemix(key, 0);
  const s1 = rsRemix(key, 8);
  const s2 = rsRemix(key, 16);
  const s3 = rsRemix(key, 24);

  // Generate the 40 round subkeys using the h function with Me and Mo
  const subKeys = new Uint32Array(40);
  for (let i = 0; i < 20; i++) {
    const byteA = 2 * i, byteB = 2 * i + 1;
    const xA = (byteA | (byteA<<8) | (byteA<<16) | (byteA<<24)) >>> 0;
    const xB = (byteB | (byteB<<8) | (byteB<<16) | (byteB<<24)) >>> 0;
    const a = hFunc(xA, Me);
    const b = ROL(hFunc(xB, Mo), 8);
    subKeys[2*i] = (a + b) >>> 0;
    subKeys[2*i+1] = ROL((a + 2*b) >>> 0, 9);
  }

  // Build the key-dependent S-box lookup tables. During encryption, the g function
  // just does 4 table lookups and XORs them together - very fast.
  // The S-box key ordering here matches the official Password Safe / LibTomCrypt code:
  //   s0 is innermost (applied first to input), s3 is outermost (applied last)
  const sBox = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
  for (let i = 0; i < 256; i++) {
    // Byte 0: q1 → s0 → q1 → s1 → q0 → s2 → q0 → s3 → q1 → MDS
    sBox[0][i] = MDS0[Q1[Q0[Q0[Q1[Q1[i]^s0[0]]^s1[0]]^s2[0]]^s3[0]]];
    // Byte 1: q0 → s0 → q1 → s1 → q1 → s2 → q0 → s3 → q0 → MDS
    sBox[1][i] = MDS1[Q0[Q0[Q1[Q1[Q0[i]^s0[1]]^s1[1]]^s2[1]]^s3[1]]];
    // Byte 2: q0 → s0 → q0 → s1 → q0 → s2 → q1 → s3 → q1 → MDS
    sBox[2][i] = MDS2[Q1[Q1[Q0[Q0[Q0[i]^s0[2]]^s1[2]]^s2[2]]^s3[2]]];
    // Byte 3: q1 → s0 → q0 → s1 → q1 → s2 → q1 → s3 → q0 → MDS
    sBox[3][i] = MDS3[Q0[Q1[Q1[Q0[Q1[i]^s0[3]]^s1[3]]^s2[3]]^s3[3]]];
  }

  return { subKeys, sBox };
}

// g function: the fast path during encryption. Just 4 S-box lookups XORed together.
function gFunc(x, sBox) {
  return (sBox[0][x & 0xFF] ^ sBox[1][(x>>>8)&0xFF] ^ sBox[2][(x>>>16)&0xFF] ^ sBox[3][(x>>>24)&0xFF]) >>> 0;
}

// Encrypt one 16-byte block with Twofish (ECB mode, no chaining)
function twofishEncryptBlock(block, ctx) {
  let r0 = rU32(block,0) ^ ctx.subKeys[0];
  let r1 = rU32(block,4) ^ ctx.subKeys[1];
  let r2 = rU32(block,8) ^ ctx.subKeys[2];
  let r3 = rU32(block,12) ^ ctx.subKeys[3];

  for (let round = 0; round < 16; round++) {
    const t0 = gFunc(r0, ctx.sBox);
    const t1 = gFunc(ROL(r1, 8), ctx.sBox);
    const f0 = (t0 + t1 + ctx.subKeys[2*round+8]) >>> 0;
    const f1 = (t0 + 2*t1 + ctx.subKeys[2*round+9]) >>> 0;
    r2 = ROR(r2 ^ f0, 1);
    r3 = ROL(r3, 1) ^ f1;
    let tmp;
    tmp = r0; r0 = r2; r2 = tmp;
    tmp = r1; r1 = r3; r3 = tmp;
  }
  // Undo last swap
  let tmp;
  tmp = r0; r0 = r2; r2 = tmp;
  tmp = r1; r1 = r3; r3 = tmp;

  const out = new Uint8Array(16);
  wU32(out, 0, (r0 ^ ctx.subKeys[4]) >>> 0);
  wU32(out, 4, (r1 ^ ctx.subKeys[5]) >>> 0);
  wU32(out, 8, (r2 ^ ctx.subKeys[6]) >>> 0);
  wU32(out, 12, (r3 ^ ctx.subKeys[7]) >>> 0);
  return out;
}

// Decrypt one 16-byte block (same structure as encrypt but rounds go backwards)
function twofishDecryptBlock(block, ctx) {
  let r0 = rU32(block,0) ^ ctx.subKeys[4];
  let r1 = rU32(block,4) ^ ctx.subKeys[5];
  let r2 = rU32(block,8) ^ ctx.subKeys[6];
  let r3 = rU32(block,12) ^ ctx.subKeys[7];

  for (let round = 15; round >= 0; round--) {
    const t0 = gFunc(r0, ctx.sBox);
    const t1 = gFunc(ROL(r1, 8), ctx.sBox);
    const f0 = (t0 + t1 + ctx.subKeys[2*round+8]) >>> 0;
    const f1 = (t0 + 2*t1 + ctx.subKeys[2*round+9]) >>> 0;
    r2 = ROL(r2, 1) ^ f0;
    r3 = ROR(r3 ^ f1, 1);
    let tmp;
    tmp = r0; r0 = r2; r2 = tmp;
    tmp = r1; r1 = r3; r3 = tmp;
  }
  // Undo last swap
  let tmp;
  tmp = r0; r0 = r2; r2 = tmp;
  tmp = r1; r1 = r3; r3 = tmp;

  const out = new Uint8Array(16);
  wU32(out, 0, (r0 ^ ctx.subKeys[0]) >>> 0);
  wU32(out, 4, (r1 ^ ctx.subKeys[1]) >>> 0);
  wU32(out, 8, (r2 ^ ctx.subKeys[2]) >>> 0);
  wU32(out, 12, (r3 ^ ctx.subKeys[3]) >>> 0);
  return out;
}

// Self-test that runs on page load to make sure the cipher actually works.
// Uses the official recursive test from the Twofish paper (ecb_ival.txt).
// Each round feeds its ciphertext back as the next plaintext and key,
// so one wrong bit anywhere cascades and the final answer won't match.
function twofishSelfTest() {
  // Run the full recursive test for 49 iterations
  // I=49 expected CT: 37FE26FF1CF66175F5DDF4C33B97A205
  const ct49 = new Uint8Array([0x37,0xFE,0x26,0xFF,0x1C,0xF6,0x61,0x75,0xF5,0xDD,0xF4,0xC3,0x3B,0x97,0xA2,0x05]);
  // Also verify I=4 (first iteration with fully non-zero key)
  const ct4 = new Uint8Array([0x6C,0xB4,0x56,0x1C,0x40,0xBF,0x0A,0x97,0x05,0x93,0x1C,0xB6,0xD4,0x08,0xE7,0xFA]);

  // CT history: ct[0]=CT[-2], ct[1]=CT[-1], ct[2]=CT[0] (all zeros)
  // We'll store the last 3 CTs
  let ctPrev3 = new Uint8Array(16); // CT[i-3]
  let ctPrev2 = new Uint8Array(16); // CT[i-2]
  let ctPrev1 = new Uint8Array(16); // CT[i-1] = plaintext for next round

  for (let round = 1; round <= 49; round++) {
    // KEY = CT[i-2] || CT[i-3]
    const key = new Uint8Array(32);
    key.set(ctPrev2);       // bytes 0-15
    key.set(ctPrev3, 16);   // bytes 16-31

    const ctx = twofishInit(key);
    const ct = twofishEncryptBlock(ctPrev1, ctx);

    // Verify I=4 intermediate
    if (round === 4) {
      for (let i = 0; i < 16; i++) if (ct[i] !== ct4[i]) return 'I=4 encrypt';
      // Also verify decrypt roundtrip
      const dec = twofishDecryptBlock(ct, ctx);
      for (let i = 0; i < 16; i++) if (dec[i] !== ctPrev1[i]) return 'I=4 decrypt';
    }

    // Shift history
    ctPrev3 = ctPrev2;
    ctPrev2 = ctPrev1;
    ctPrev1 = ct;
  }

  // Verify final CT[49]
  for (let i = 0; i < 16; i++) if (ctPrev1[i] !== ct49[i]) return 'I=49 final';

  return true;
}

// =====================================================================
// CBC MODE (Cipher Block Chaining)
// Each block is XORed with the previous ciphertext block before
// encryption, so identical plaintext blocks produce different output.
// Password Safe uses this for all field data after the 152-byte header.
// =====================================================================

function cbcDecrypt(data, ctx, iv) {
  const blocks = data.length / 16;
  const out = new Uint8Array(data.length);
  let prevCt = iv;
  for (let i = 0; i < blocks; i++) {
    const off = i * 16;
    const ctBlock = data.slice(off, off + 16);
    const ptBlock = twofishDecryptBlock(ctBlock, ctx);
    for (let j = 0; j < 16; j++) out[off + j] = ptBlock[j] ^ prevCt[j];
    prevCt = ctBlock;
  }
  return out;
}

function cbcEncrypt(data, ctx, iv) {
  const blocks = data.length / 16;
  const out = new Uint8Array(data.length);
  let prev = iv;
  for (let i = 0; i < blocks; i++) {
    const off = i * 16;
    const xored = new Uint8Array(16);
    for (let j = 0; j < 16; j++) xored[j] = data[off + j] ^ prev[j];
    const ctBlock = twofishEncryptBlock(xored, ctx);
    out.set(ctBlock, off);
    prev = ctBlock;
  }
  return out;
}

// =====================================================================
// CRYPTO HELPERS
// These use the browser's built-in Web Crypto API (crypto.subtle) for
// SHA-256 and HMAC. These are the only browser APIs we rely on besides
// crypto.getRandomValues for random number generation.
// =====================================================================

async function sha256(data) {
  const buf = await crypto.subtle.digest('SHA-256', data);
  return new Uint8Array(buf);
}

async function hmacSha256(key, data) {
  const cryptoKey = await crypto.subtle.importKey('raw', key, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
  const sig = await crypto.subtle.sign('HMAC', cryptoKey, data);
  return new Uint8Array(sig);
}

async function stretchKey(password, salt, iterations) {
  const encoder = new TextEncoder();
  const passBytes = encoder.encode(password);
  const combined = new Uint8Array(passBytes.length + salt.length);
  combined.set(passBytes);
  combined.set(salt, passBytes.length);
  let hash = await sha256(combined);
  for (let i = 0; i < iterations; i++) {
    hash = await sha256(hash);
  }
  return hash;
}

// =====================================================================
// PSAFE3 FORMAT PARSER & WRITER
// =====================================================================

const TAG = new Uint8Array([0x50, 0x57, 0x53, 0x33]); // "PWS3"
const EOF_MARKER = new TextEncoder().encode('PWS3-EOFPWS3-EOF');

// Header field types
const HDR_VERSION = 0x00;
const HDR_UUID = 0x01;
const HDR_PREFS = 0x02;
const HDR_TREE = 0x03;
const HDR_SAVE_TIME = 0x04;
const HDR_SAVE_WHO = 0x05;
const HDR_SAVE_WHAT = 0x06;
const HDR_SAVE_USER = 0x07;
const HDR_SAVE_HOST = 0x08;
const HDR_DB_NAME = 0x09;
const HDR_DB_DESC = 0x0A;
const HDR_END = 0xFF;

// Record field types
const REC_UUID = 0x01;
const REC_GROUP = 0x02;
const REC_TITLE = 0x03;
const REC_USER = 0x04;
const REC_NOTES = 0x05;
const REC_PASSWORD = 0x06;
const REC_CTIME = 0x07;
const REC_PMTIME = 0x08;
const REC_ATIME = 0x09;
const REC_EXPTIME = 0x0A;
const REC_MTIME = 0x0C;
const REC_URL = 0x0D;
const REC_AUTOTYPE = 0x0E;
const REC_PWHIST = 0x0F;
const REC_POLICY = 0x10;
const REC_XINT = 0x11;
const REC_RUNCMD = 0x12;
const REC_EMAIL = 0x14;
const REC_PROTECTED = 0x15;
const REC_SYMBOLS = 0x16;
const REC_POLICYNAME = 0x18;
const REC_KBSHORTCUT = 0x19;
const REC_END = 0xFF;

const textDec = new TextDecoder('utf-8');

function parseFields(plaintext) {
  const fields = [];
  let offset = 0;
  while (offset + 5 <= plaintext.length) {
    const dataLen = rU32(plaintext, offset);
    const type = plaintext[offset + 4];
    const rawSize = 5 + dataLen;
    const paddedSize = Math.ceil(rawSize / 16) * 16;
    if (offset + paddedSize > plaintext.length) break;
    const data = plaintext.slice(offset + 5, offset + 5 + dataLen);
    fields.push({ type, data });
    offset += paddedSize;
  }
  return fields;
}

function readText(data) { return textDec.decode(data); }
function readTime(data) { return data.length >= 4 ? rU32(data, 0) : 0; }
function readU16(data) { return data.length >= 2 ? (data[0] | (data[1] << 8)) : 0; }

function fieldsToHeader(fields) {
  const hdr = { version: 0x030D, uuid: null, dbName: '', dbDesc: '', prefs: '', tree: '',
    saveTime: 0, saveWho: '', saveWhat: '', saveUser: '', saveHost: '', rawFields: [] };
  for (const f of fields) {
    hdr.rawFields.push(f);
    switch (f.type) {
      case HDR_VERSION: hdr.version = readU16(f.data); break;
      case HDR_UUID: hdr.uuid = new Uint8Array(f.data); break;
      case HDR_DB_NAME: hdr.dbName = readText(f.data); break;
      case HDR_DB_DESC: hdr.dbDesc = readText(f.data); break;
      case HDR_PREFS: hdr.prefs = readText(f.data); break;
      case HDR_TREE: hdr.tree = readText(f.data); break;
      case HDR_SAVE_TIME: hdr.saveTime = readTime(f.data); break;
      case HDR_SAVE_WHO: hdr.saveWho = readText(f.data); break;
      case HDR_SAVE_WHAT: hdr.saveWhat = readText(f.data); break;
      case HDR_SAVE_USER: hdr.saveUser = readText(f.data); break;
      case HDR_SAVE_HOST: hdr.saveHost = readText(f.data); break;
    }
  }
  return hdr;
}

function fieldsToRecord(fields) {
  const rec = { uuid: null, group: '', title: '', username: '', password: '', notes: '',
    url: '', email: '', autotype: '', runCmd: '', symbols: '', policyName: '',
    ctime: 0, pmtime: 0, atime: 0, exptime: 0, mtime: 0, protected: false,
    rawFields: [] };
  for (const f of fields) {
    rec.rawFields.push(f);
    switch (f.type) {
      case REC_UUID: rec.uuid = new Uint8Array(f.data); break;
      case REC_GROUP: rec.group = readText(f.data); break;
      case REC_TITLE: rec.title = readText(f.data); break;
      case REC_USER: rec.username = readText(f.data); break;
      case REC_PASSWORD: rec.password = readText(f.data); break;
      case REC_NOTES: rec.notes = readText(f.data); break;
      case REC_URL: rec.url = readText(f.data); break;
      case REC_EMAIL: rec.email = readText(f.data); break;
      case REC_AUTOTYPE: rec.autotype = readText(f.data); break;
      case REC_RUNCMD: rec.runCmd = readText(f.data); break;
      case REC_SYMBOLS: rec.symbols = readText(f.data); break;
      case REC_POLICYNAME: rec.policyName = readText(f.data); break;
      case REC_CTIME: rec.ctime = readTime(f.data); break;
      case REC_PMTIME: rec.pmtime = readTime(f.data); break;
      case REC_ATIME: rec.atime = readTime(f.data); break;
      case REC_EXPTIME: rec.exptime = readTime(f.data); break;
      case REC_MTIME: rec.mtime = readTime(f.data); break;
      case REC_PROTECTED: rec.protected = f.data.length > 0 && f.data[0] !== 0; break;
    }
  }
  return rec;
}

// Diagnostic logger - collects debug info during open
let debugLog = [];
function dbg(msg) { debugLog.push(msg); }
function hexBytes(arr, n) { return Array.from(arr.slice(0, n || arr.length)).map(b => b.toString(16).padStart(2,'0')).join(' '); }

async function openVault(fileData, password) {
  debugLog = [];
  const buf = new Uint8Array(fileData);
  dbg('File size: ' + buf.length + ' bytes');

  // Per Password Safe V3 format spec:
  // [TAG 4][SALT 32][ITER 4][H(P') 32][B1 16][B2 16][B3 16][B4 16][IV 16] = 152 bytes
  // [Encrypted fields N*16][EOF plaintext 16][HMAC 32]
  // Total minimum = 152 + 16 + 16 + 32 = 216 bytes
  if (buf.length < 200) throw new Error('File too small (' + buf.length + ' bytes)');

  // Check tag
  const tagStr = String.fromCharCode(buf[0], buf[1], buf[2], buf[3]);
  dbg('Tag: "' + tagStr + '"');
  for (let i = 0; i < 4; i++) if (buf[i] !== TAG[i]) throw new Error('Not a valid .psafe3 file (tag: "' + tagStr + '")');

  const salt = buf.slice(4, 36);
  const iter = rU32(buf, 36);
  const storedHP = buf.slice(40, 72);
  const b1 = buf.slice(72, 88);
  const b2 = buf.slice(88, 104);
  const b3 = buf.slice(104, 120);
  const b4 = buf.slice(120, 136);
  const iv = buf.slice(136, 152);

  dbg('Iterations: ' + iter);
  dbg('Salt: ' + hexBytes(salt));
  dbg('B1: ' + hexBytes(b1));
  dbg('B2: ' + hexBytes(b2));
  dbg('B3: ' + hexBytes(b3));
  dbg('B4: ' + hexBytes(b4));
  dbg('IV: ' + hexBytes(iv));

  // Check for plaintext EOF marker at file_size - 48
  const possibleEof = buf.slice(buf.length - 48, buf.length - 32);
  let hasPlaintextEof = true;
  for (let i = 0; i < 16; i++) {
    if (possibleEof[i] !== EOF_MARKER[i]) { hasPlaintextEof = false; break; }
  }
  dbg('Plaintext EOF at file_size-48: ' + (hasPlaintextEof ? 'YES' : 'no'));

  const storedHMAC = buf.slice(buf.length - 32);
  dbg('Stored HMAC: ' + hexBytes(storedHMAC));

  // Stretch key
  dbg('Stretching key (' + iter + ' iterations)...');
  const pPrime = await stretchKey(password, salt, iter);
  dbg('P\' (stretched key): ' + hexBytes(pPrime));

  // Verify password
  const hpCheck = await sha256(pPrime);
  dbg('SHA256(P\'): ' + hexBytes(hpCheck));
  dbg('Stored H(P\'): ' + hexBytes(storedHP));
  let pwMatch = true;
  for (let i = 0; i < 32; i++) {
    if (hpCheck[i] !== storedHP[i]) { pwMatch = false; break; }
  }
  if (!pwMatch) throw new Error('Incorrect password');
  dbg('Password verified OK');

  // Twofish non-zero key verification: encrypt known test vector with P' and check
  // This catches any browser-specific Twofish bugs with the actual key being used
  const tfVerify = twofishInit(pPrime);
  const testPt = new Uint8Array(16); // all zeros
  const testCt = twofishEncryptBlock(testPt, tfVerify);
  const testDec = twofishDecryptBlock(testCt, tfVerify);
  let tfOk = true;
  for (let i = 0; i < 16; i++) if (testDec[i] !== 0) { tfOk = false; break; }
  dbg('Twofish roundtrip with P\' key: ' + (tfOk ? 'OK' : 'FAILED'));

  // Decrypt K and L using Twofish-ECB with P' as key
  const tfPrime = twofishInit(pPrime);
  const k1 = twofishDecryptBlock(b1, tfPrime);
  const k2 = twofishDecryptBlock(b2, tfPrime);
  const keyK = new Uint8Array(32);
  keyK.set(k1); keyK.set(k2, 16);

  const l1 = twofishDecryptBlock(b3, tfPrime);
  const l2 = twofishDecryptBlock(b4, tfPrime);
  const keyL = new Uint8Array(32);
  keyL.set(l1); keyL.set(l2, 16);

  dbg('Decrypted K: ' + hexBytes(keyK));
  dbg('Decrypted L: ' + hexBytes(keyL));

  // Try decryption with multiple layout strategies
  // Strategy 1: Plaintext EOF (per spec) - enc = file_size - 200
  // Strategy 2: Encrypted EOF (legacy) - enc = file_size - 184
  // Strategy 3: Same as 1 but with K halves swapped (B2||B1)
  const strategies = [];
  if (hasPlaintextEof) {
    const encSize = buf.length - 200;
    if (encSize > 0 && encSize % 16 === 0) {
      strategies.push({ name: 'plaintext-eof', encSize, useAllAsFieldData: true });
      strategies.push({ name: 'plaintext-eof-swapK', encSize, useAllAsFieldData: true, swapK: true });
    }
  }
  {
    const encSize = buf.length - 184;
    if (encSize > 0 && encSize % 16 === 0) {
      strategies.push({ name: 'encrypted-eof', encSize, useAllAsFieldData: false });
      strategies.push({ name: 'encrypted-eof-swapK', encSize, useAllAsFieldData: false, swapK: true });
    }
  }

  let bestResult = null;
  for (const strat of strategies) {
    const encData = buf.slice(152, 152 + strat.encSize);
    let kToUse = keyK;
    if (strat.swapK) {
      kToUse = new Uint8Array(32);
      kToUse.set(k2); kToUse.set(k1, 16);
    }
    const tfK = twofishInit(kToUse);
    const pt = cbcDecrypt(encData, tfK, iv);
    const firstLen = pt.length >= 5 ? rU32(pt, 0) : 0xFFFFFFFF;
    const firstType = pt.length >= 5 ? pt[4] : 0xFF;

    // Check if decryption looks valid: first field should be Version (type 0x00) with len 2
    const looksValid = (firstType === 0x00 && firstLen === 2) || (firstLen < 10000 && firstType <= 0x20);
    dbg('Strategy "' + strat.name + '": encSize=' + strat.encSize + ', firstLen=' + firstLen + ', firstType=0x' + firstType.toString(16).padStart(2,'0') + (looksValid ? ' [VALID]' : ''));

    if (looksValid && !bestResult) {
      // Find field data boundary
      let fieldData;
      if (strat.useAllAsFieldData) {
        fieldData = pt;
      } else {
        // Look for EOF marker in decrypted data
        let eofOff = -1;
        for (let off = pt.length - 16; off >= 0; off -= 16) {
          let m = true;
          for (let j = 0; j < 16; j++) if (pt[off + j] !== EOF_MARKER[j]) { m = false; break; }
          if (m) { eofOff = off; break; }
        }
        fieldData = eofOff >= 0 ? pt.slice(0, eofOff) : pt;
      }
      bestResult = { fieldData, keyL: strat.swapK ? keyL : keyL, strat: strat.name };
    }
  }

  if (!bestResult) {
    // Dump extensive debug info
    dbg('--- NO STRATEGY PRODUCED VALID DATA ---');

    // K roundtrip verification: prove Twofish works with the actual key K
    const tfKtest = twofishInit(keyK);
    const testBlock = new Uint8Array(16);
    for (let j = 0; j < 16; j++) testBlock[j] = j; // 00 01 02 ... 0F
    const kEnc = twofishEncryptBlock(testBlock, tfKtest);
    const kDec = twofishDecryptBlock(kEnc, tfKtest);
    let kRoundtrip = true;
    for (let j = 0; j < 16; j++) if (kDec[j] !== j) { kRoundtrip = false; break; }
    dbg('Twofish roundtrip with K: ' + (kRoundtrip ? 'OK' : 'FAILED'));

    // ECB-only decryption of first ciphertext block (no CBC XOR) to isolate issues
    const firstCtBlock = buf.slice(152, 168);
    dbg('First ciphertext block (raw): ' + hexBytes(firstCtBlock));
    const ecbOnly = twofishDecryptBlock(firstCtBlock, tfKtest);
    dbg('First block ECB decrypt only: ' + hexBytes(ecbOnly));
    // Now XOR with IV to get CBC result
    const cbcResult = new Uint8Array(16);
    for (let j = 0; j < 16; j++) cbcResult[j] = ecbOnly[j] ^ iv[j];
    dbg('First block ECB^IV (CBC):     ' + hexBytes(cbcResult));
    const cbcLen = rU32(cbcResult, 0);
    const cbcType = cbcResult[4];
    dbg('First field: type=0x' + cbcType.toString(16).padStart(2,'0') + ' len=' + cbcLen +
        (cbcType === 0x00 && cbcLen === 2 ? ' [looks like Version field]' : ' [unexpected]'));

    // Full 4-block CBC decrypt
    dbg('Encrypted data (first 64 bytes): ' + hexBytes(buf.slice(152, 216)));
    const tfK = twofishInit(keyK);
    const rawDec = cbcDecrypt(buf.slice(152, 152 + 64), tfK, iv);
    dbg('CBC decrypted first 4 blocks with K (B1||B2):');
    for (let i = 0; i < 4; i++) {
      const blk = rawDec.slice(i*16, i*16+16);
      const txt = Array.from(blk).map(b => b >= 32 && b < 127 ? String.fromCharCode(b) : '.').join('');
      dbg('  Block ' + i + ': ' + hexBytes(blk) + ' | ' + txt);
    }
    // Also try with swapped K
    const keyKswap = new Uint8Array(32);
    keyKswap.set(k2); keyKswap.set(k1, 16);
    const tfKs = twofishInit(keyKswap);
    const rawDecS = cbcDecrypt(buf.slice(152, 152 + 64), tfKs, iv);
    dbg('CBC decrypted first 4 blocks with K (B2||B1):');
    for (let i = 0; i < 4; i++) {
      const blk = rawDecS.slice(i*16, i*16+16);
      const txt = Array.from(blk).map(b => b >= 32 && b < 127 ? String.fromCharCode(b) : '.').join('');
      dbg('  Block ' + i + ': ' + hexBytes(blk) + ' | ' + txt);
    }

    // B1/B2 verification: re-encrypt the decrypted K and compare with original B1/B2
    const reEncB1 = twofishEncryptBlock(k1, tfPrime);
    const reEncB2 = twofishEncryptBlock(k2, tfPrime);
    let b1Match = true, b2Match = true;
    for (let j = 0; j < 16; j++) { if (reEncB1[j] !== b1[j]) b1Match = false; if (reEncB2[j] !== b2[j]) b2Match = false; }
    dbg('B1 re-encrypt match: ' + (b1Match ? 'YES' : 'NO'));
    dbg('B2 re-encrypt match: ' + (b2Match ? 'YES' : 'NO'));

    throw new Error('Decryption failed - no valid field structure found. See debug log below.');
  }

  dbg('Using strategy: ' + bestResult.strat);
  const fieldData = bestResult.fieldData;
  dbg('Field data size: ' + fieldData.length + ' bytes');

  // Parse fields from decrypted data
  const allFields = parseFields(fieldData);
  dbg('Parsed ' + allFields.length + ' fields');

  // Log field types
  for (let i = 0; i < Math.min(allFields.length, 20); i++) {
    const f = allFields[i];
    let val = '';
    if (f.data.length <= 40) {
      try { val = ' = "' + new TextDecoder().decode(f.data).substring(0, 30) + '"'; } catch(e) {}
    }
    dbg('  Field ' + i + ': type=0x' + f.type.toString(16).padStart(2,'0') + ' len=' + f.data.length + val);
  }
  if (allFields.length > 20) dbg('  ... and ' + (allFields.length - 20) + ' more fields');

  // Compute HMAC over field data and verify
  let hmacLen = 0;
  for (const f of allFields) hmacLen += f.data.length;
  const hmacBuf = new Uint8Array(hmacLen);
  let hmacOff = 0;
  for (const f of allFields) {
    hmacBuf.set(f.data, hmacOff);
    hmacOff += f.data.length;
  }
  dbg('HMAC input size: ' + hmacLen + ' bytes');
  const computedHMAC = await hmacSha256(keyL, hmacBuf);
  dbg('Computed HMAC: ' + hexBytes(computedHMAC));
  dbg('Stored HMAC:   ' + hexBytes(storedHMAC));

  let hmacMatch = true;
  for (let i = 0; i < 32; i++) {
    if (computedHMAC[i] !== storedHMAC[i]) { hmacMatch = false; break; }
  }
  if (!hmacMatch) {
    dbg('HMAC MISMATCH');
    throw new Error('HMAC verification failed. See debug log below.');
  }
  dbg('HMAC verified OK');

  // Split into header and records
  let headerFields = [];
  const records = [];
  let current = [];
  let inHeader = true;

  for (const f of allFields) {
    if (f.type === HDR_END && inHeader) {
      headerFields = current;
      current = [];
      inHeader = false;
    } else if (f.type === REC_END && !inHeader) {
      records.push(fieldsToRecord(current));
      current = [];
    } else {
      current.push(f);
    }
  }

  dbg('Header fields: ' + headerFields.length + ', Records: ' + records.length);
  const header = fieldsToHeader(headerFields);
  return { header, records, iter };
}

// Serialize fields to binary
// Strategy: preserve rawFields from the original file for maximum compatibility.
// Only override fields the user can edit in the UI. Unknown/unsupported field types
// (password history, policies, keyboard shortcuts, etc.) pass through untouched.
function serializeFields(header, records) {
  const enc = new TextEncoder();
  const allFieldData = []; // for HMAC
  const blocks = [];

  function addField(type, data) {
    allFieldData.push(data);
    const rawLen = 5 + data.length;
    const padLen = Math.ceil(rawLen / 16) * 16;
    const block = new Uint8Array(padLen);
    wU32(block, 0, data.length);
    block[4] = type;
    block.set(data, 5);
    // Fill padding with random bytes
    if (padLen > rawLen) {
      const pad = new Uint8Array(padLen - rawLen);
      crypto.getRandomValues(pad);
      block.set(pad, rawLen);
    }
    blocks.push(block);
  }

  function addTextField(type, text) { addField(type, enc.encode(text)); }
  function addTimeField(type, time) {
    const d = new Uint8Array(4);
    wU32(d, 0, time);
    addField(type, d);
  }
  function addEndField() { addField(0xFF, new Uint8Array(0)); }

  const now = Math.floor(Date.now() / 1000);

  // --- Header fields ---
  if (header.rawFields && header.rawFields.length > 0) {
    // Existing vault: preserve all original fields, only override save metadata
    for (const f of header.rawFields) {
      if (f.type === HDR_SAVE_TIME) {
        addTimeField(HDR_SAVE_TIME, now);
      } else if (f.type === HDR_SAVE_WHAT) {
        addTextField(HDR_SAVE_WHAT, 'Password Safe Web Client');
      } else {
        // Pass through as-is (preserves SAVE_USER, SAVE_HOST, prefs, tree, unknown types, etc.)
        addField(f.type, f.data);
      }
    }
    // Ensure save metadata exists even if not in original file
    const seenTypes = new Set(header.rawFields.map(f => f.type));
    if (!seenTypes.has(HDR_SAVE_TIME)) addTimeField(HDR_SAVE_TIME, now);
    if (!seenTypes.has(HDR_SAVE_WHAT)) addTextField(HDR_SAVE_WHAT, 'Password Safe Web Client');
  } else {
    // New vault: write minimal header
    const verData = new Uint8Array(2);
    verData[0] = header.version & 0xFF;
    verData[1] = (header.version >>> 8) & 0xFF;
    addField(HDR_VERSION, verData);
    if (header.uuid) addField(HDR_UUID, header.uuid);
    if (header.prefs) addTextField(HDR_PREFS, header.prefs);
    if (header.tree) addTextField(HDR_TREE, header.tree);
    addTimeField(HDR_SAVE_TIME, now);
    addTextField(HDR_SAVE_WHAT, 'Password Safe Web Client');
    if (header.dbName) addTextField(HDR_DB_NAME, header.dbName);
    if (header.dbDesc) addTextField(HDR_DB_DESC, header.dbDesc);
  }
  addEndField();

  // --- Record fields ---
  for (const rec of records) {
    if (rec.rawFields && rec.rawFields.length > 0) {
      // Existing record: preserve rawFields, override only UI-editable fields.
      // This preserves password history, policies, autotype, run commands, keyboard
      // shortcuts, protection flags, and any unknown/future field types.
      const editableOverrides = {
        [REC_TITLE]: () => addTextField(REC_TITLE, rec.title || 'Untitled'),
        [REC_GROUP]: () => { if (rec.group) addTextField(REC_GROUP, rec.group); },
        [REC_USER]: () => { if (rec.username) addTextField(REC_USER, rec.username); },
        [REC_PASSWORD]: () => addTextField(REC_PASSWORD, rec.password || ''),
        [REC_NOTES]: () => { if (rec.notes) addTextField(REC_NOTES, rec.notes); },
        [REC_URL]: () => { if (rec.url) addTextField(REC_URL, rec.url); },
        [REC_EMAIL]: () => { if (rec.email) addTextField(REC_EMAIL, rec.email); },
        [REC_MTIME]: () => addTimeField(REC_MTIME, now),
        [REC_PMTIME]: () => addTimeField(REC_PMTIME, rec.pmtime || 0),
      };

      const seen = new Set();
      const overridden = new Set();
      for (const f of rec.rawFields) {
        seen.add(f.type);
        const override = editableOverrides[f.type];
        if (override && !overridden.has(f.type)) {
          overridden.add(f.type);
          override();
        } else if (!override) {
          // Preserve non-editable field as-is (pwhist, policy, autotype, kbshortcut, etc.)
          addField(f.type, f.data);
        }
        // Skip duplicate editable fields (shouldn't happen but be safe)
      }

      // Add mtime if not present in original
      if (!seen.has(REC_MTIME)) addTimeField(REC_MTIME, now);
      // Add newly-set fields that weren't in the original record
      if (!seen.has(REC_GROUP) && rec.group) addTextField(REC_GROUP, rec.group);
      if (!seen.has(REC_URL) && rec.url) addTextField(REC_URL, rec.url);
      if (!seen.has(REC_EMAIL) && rec.email) addTextField(REC_EMAIL, rec.email);
      if (!seen.has(REC_NOTES) && rec.notes) addTextField(REC_NOTES, rec.notes);
      if (!seen.has(REC_PMTIME) && rec.pmtime) addTimeField(REC_PMTIME, rec.pmtime);
    } else {
      // New record: write all fields from scratch
      if (rec.uuid) addField(REC_UUID, rec.uuid);
      else { const u = new Uint8Array(16); crypto.getRandomValues(u); u[6]=(u[6]&0x0F)|0x40; u[8]=(u[8]&0x3F)|0x80; addField(REC_UUID, u); }
      if (rec.group) addTextField(REC_GROUP, rec.group);
      addTextField(REC_TITLE, rec.title || 'Untitled');
      if (rec.username) addTextField(REC_USER, rec.username);
      addTextField(REC_PASSWORD, rec.password || '');
      if (rec.notes) addTextField(REC_NOTES, rec.notes);
      if (rec.url) addTextField(REC_URL, rec.url);
      if (rec.email) addTextField(REC_EMAIL, rec.email);
      addTimeField(REC_CTIME, rec.ctime || now);
      addTimeField(REC_MTIME, rec.mtime || now);
      if (rec.pmtime) addTimeField(REC_PMTIME, rec.pmtime);
    }
    addEndField();
  }

  // Concat all blocks
  let totalLen = 0;
  for (const b of blocks) totalLen += b.length;
  const result = new Uint8Array(totalLen);
  let off = 0;
  for (const b of blocks) { result.set(b, off); off += b.length; }

  // HMAC data
  let hmacTotalLen = 0;
  for (const d of allFieldData) hmacTotalLen += d.length;
  const hmacBuf = new Uint8Array(hmacTotalLen);
  let hmacOff = 0;
  for (const d of allFieldData) { hmacBuf.set(d, hmacOff); hmacOff += d.length; }

  return { plaintext: result, hmacData: hmacBuf };
}

async function saveVault(header, records, password, iter) {
  iter = iter || 2048;
  const salt = new Uint8Array(32);
  crypto.getRandomValues(salt);

  const pPrime = await stretchKey(password, salt, iter);
  const hpPrime = await sha256(pPrime);

  // Generate random keys K and L
  const keyK = new Uint8Array(32);
  const keyL = new Uint8Array(32);
  crypto.getRandomValues(keyK);
  crypto.getRandomValues(keyL);

  // Encrypt K and L with Twofish-ECB using P'
  const tfPrime = twofishInit(pPrime);
  const b1 = twofishEncryptBlock(keyK.slice(0, 16), tfPrime);
  const b2 = twofishEncryptBlock(keyK.slice(16, 32), tfPrime);
  const b3 = twofishEncryptBlock(keyL.slice(0, 16), tfPrime);
  const b4 = twofishEncryptBlock(keyL.slice(16, 32), tfPrime);

  // Generate IV
  const iv = new Uint8Array(16);
  crypto.getRandomValues(iv);

  // Serialize fields
  const { plaintext, hmacData } = serializeFields(header, records);

  // Encrypt fields only (EOF marker is written as plaintext per V3 spec)
  const tfK = twofishInit(keyK);
  const encrypted = cbcEncrypt(plaintext, tfK, iv);

  // Compute HMAC over field data only (not EOF marker)
  const hmac = await hmacSha256(keyL, hmacData);

  // Build file: [Header 152][Encrypted N*16][EOF plaintext 16][HMAC 32]
  const iterBuf = new Uint8Array(4);
  wU32(iterBuf, 0, iter);

  const fileSize = 152 + encrypted.length + 16 + 32;
  const file = new Uint8Array(fileSize);
  let off = 0;
  file.set(TAG, off); off += 4;
  file.set(salt, off); off += 32;
  file.set(iterBuf, off); off += 4;
  file.set(hpPrime, off); off += 32;
  file.set(b1, off); off += 16;
  file.set(b2, off); off += 16;
  file.set(b3, off); off += 16;
  file.set(b4, off); off += 16;
  file.set(iv, off); off += 16;
  file.set(encrypted, off); off += encrypted.length;
  file.set(EOF_MARKER, off); off += 16;
  file.set(hmac, off);

  // Roundtrip verification: re-open the generated file to ensure it's valid
  const verifyVault = await openVault(file.buffer, password);
  if (verifyVault.records.length !== records.length) {
    throw new Error('Save verification failed: record count mismatch (expected ' +
      records.length + ', got ' + verifyVault.records.length + ')');
  }
  for (let i = 0; i < records.length; i++) {
    const origUuid = uuidToHex(records[i].uuid);
    const found = verifyVault.records.find(r => uuidToHex(r.uuid) === origUuid);
    if (!found) {
      throw new Error('Save verification failed: record "' + (records[i].title || 'Untitled') + '" missing after re-open');
    }
    if (found.password !== (records[i].password || '')) {
      throw new Error('Save verification failed: password mismatch for "' + (records[i].title || 'Untitled') + '"');
    }
  }

  return file;
}

// =====================================================================
// APPLICATION UI
// =====================================================================

let appState = {
  screen: 'open',
  vault: null,
  password: null,
  fileName: null,
  selectedIdx: -1,
  editing: false,
  modified: false
};

// DOM references
const $ = id => document.getElementById(id);
const screenOpen = $('screen-open');
const screenVault = $('screen-vault');
const fileInput = $('file-input');
const masterPw = $('master-password');
const btnOpen = $('btn-open');
const btnNew = $('btn-new');
const statusEl = $('status');
const searchBox = $('search-box');
const entryListEl = $('entry-list');
const entryDetailEl = $('entry-detail');
const vaultNameEl = $('vault-name');
const modalOverlay = $('modal-overlay');
const modalContent = $('modal-content');

let loadedFileData = null;

function showStatus(msg, cls) {
  statusEl.textContent = msg;
  statusEl.className = cls ? 'status-' + cls : '';
}

function showToast(msg) {
  const t = document.createElement('div');
  t.className = 'toast';
  t.textContent = msg;
  document.body.appendChild(t);
  setTimeout(() => t.remove(), 2000);
}

function showModal(html, onClose) {
  modalContent.innerHTML = html;
  modalOverlay.classList.remove('hidden');
  const closer = () => { modalOverlay.classList.add('hidden'); if (onClose) onClose(); };
  modalOverlay.onclick = e => { if (e.target === modalOverlay) closer(); };
  return closer;
}

function copyText(text) {
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(text).then(() => showToast('Copied')).catch(() => fallbackCopy(text));
  } else {
    fallbackCopy(text);
  }
}
function fallbackCopy(text) {
  const ta = document.createElement('textarea');
  ta.value = text;
  ta.style.cssText = 'position:fixed;left:-9999px';
  document.body.appendChild(ta);
  ta.select();
  document.execCommand('copy');
  document.body.removeChild(ta);
  showToast('Copied');
}

function formatTime(ts) {
  if (!ts) return '-';
  return new Date(ts * 1000).toLocaleString();
}

function uuidToHex(bytes) {
  if (!bytes) return '';
  return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
}

// File input handling
fileInput.addEventListener('change', () => {
  const file = fileInput.files[0];
  if (!file) return;
  appState.fileName = file.name;
  const reader = new FileReader();
  reader.onload = () => {
    loadedFileData = reader.result;
    btnOpen.disabled = false;
  };
  reader.readAsArrayBuffer(file);
});

masterPw.addEventListener('keydown', e => {
  if (e.key === 'Enter' && !btnOpen.disabled) btnOpen.click();
});

// Open vault
btnOpen.addEventListener('click', async () => {
  if (!loadedFileData || !masterPw.value) {
    showStatus('Please select a file and enter password', 'error');
    return;
  }
  showStatus('Decrypting vault...', 'info');
  btnOpen.disabled = true;
  try {
    // Run self-test first
    const selfTest = twofishSelfTest();
    if (selfTest !== true) {
      showStatus('Crypto self-test failed: ' + selfTest, 'error');
      btnOpen.disabled = false;
      return;
    }
    const vault = await openVault(loadedFileData, masterPw.value);
    appState.vault = vault;
    appState.password = masterPw.value;
    appState.modified = false;
    masterPw.value = '';
    showVaultScreen();
  } catch (e) {
    // Build debug log text
    const logText = debugLog.join('\n');
    // Show error + full debug log in a big visible box
    statusEl.innerHTML = '<div style="text-align:left">' +
      '<p style="color:#ef4444;font-weight:bold;margin-bottom:10px">' + escHtml(e.message) + '</p>' +
      (debugLog.length > 0 ?
        '<p style="font-size:12px;margin-bottom:6px;color:#666">Debug log (copy and share for troubleshooting):</p>' +
        '<textarea id="debug-log-area" readonly style="width:100%;height:250px;font-family:monospace;font-size:11px;padding:8px;border:1px solid #ccc;border-radius:6px;background:#1a1a2e;color:#e0e0e0;resize:vertical">' +
        escHtml(logText) + '</textarea>' +
        '<button onclick="document.getElementById(\'debug-log-area\').select();document.execCommand(\'copy\')" ' +
        'style="margin-top:6px;padding:4px 12px;font-size:12px;cursor:pointer;border:1px solid #ccc;border-radius:4px;background:#fff">Copy Log</button>'
      : '<p style="color:#999;font-size:12px">No debug log (you may be running an old version - refresh the page)</p>') +
      '</div>';
    statusEl.className = '';
    btnOpen.disabled = false;
  }
});

// New vault
btnNew.addEventListener('click', () => {
  const close = showModal(`
    <h3>Create New Vault</h3>
    <div class="form-group"><label>Vault Name</label><input type="text" id="new-vault-name" placeholder="My Vault"></div>
    <div class="form-group"><label>Master Password</label><input type="password" id="new-vault-pw" autocomplete="off"></div>
    <div class="form-group"><label>Confirm Password</label><input type="password" id="new-vault-pw2" autocomplete="off"></div>
    <div class="btn-row">
      <button class="btn btn-primary" id="new-vault-ok">Create</button>
      <button class="btn btn-secondary" id="new-vault-cancel">Cancel</button>
    </div>
    <div id="new-vault-err" style="color:#ef4444;font-size:13px;margin-top:8px"></div>
  `);

  $('new-vault-cancel').onclick = close;
  $('new-vault-ok').onclick = () => {
    const name = $('new-vault-name').value || 'My Vault';
    const pw = $('new-vault-pw').value;
    const pw2 = $('new-vault-pw2').value;
    if (!pw) { $('new-vault-err').textContent = 'Password required'; return; }
    if (pw !== pw2) { $('new-vault-err').textContent = 'Passwords do not match'; return; }
    const uuid = new Uint8Array(16);
    crypto.getRandomValues(uuid);
    uuid[6] = (uuid[6] & 0x0F) | 0x40;
    uuid[8] = (uuid[8] & 0x3F) | 0x80;
    appState.vault = {
      header: { version: 0x030D, uuid, dbName: name, dbDesc: '', prefs: '', tree: '',
        saveTime: 0, saveWho: '', saveWhat: '', saveUser: '', saveHost: '', rawFields: [] },
      records: [],
      iter: 2048
    };
    appState.password = pw;
    appState.fileName = name.replace(/[^a-zA-Z0-9]/g, '_') + '.psafe3';
    appState.modified = true;
    close();
    showVaultScreen();
  };
});

function showVaultScreen() {
  screenOpen.classList.add('hidden');
  screenVault.classList.remove('hidden');
  vaultNameEl.textContent = appState.vault.header.dbName || 'Vault';
  appState.selectedIdx = -1;
  appState.editing = false;
  searchBox.value = '';
  renderEntryList();
  renderDetail();
}

function showOpenScreen() {
  screenVault.classList.add('hidden');
  screenOpen.classList.remove('hidden');
  appState.vault = null;
  appState.password = null;
  loadedFileData = null;
  fileInput.value = '';
  btnOpen.disabled = true;
  showStatus('', '');
}

function getFilteredRecords() {
  const term = searchBox.value.toLowerCase();
  const recs = appState.vault.records;
  if (!term) return recs.map((r, i) => ({ rec: r, idx: i }));
  return recs.map((r, i) => ({ rec: r, idx: i }))
    .filter(({ rec }) =>
      (rec.title && rec.title.toLowerCase().includes(term)) ||
      (rec.username && rec.username.toLowerCase().includes(term)) ||
      (rec.group && rec.group.toLowerCase().includes(term)) ||
      (rec.url && rec.url.toLowerCase().includes(term)) ||
      (rec.email && rec.email.toLowerCase().includes(term)) ||
      (rec.notes && rec.notes.toLowerCase().includes(term))
    );
}

function renderEntryList() {
  const items = getFilteredRecords();
  // Group by group name
  const groups = {};
  for (const item of items) {
    const g = item.rec.group || '(No Group)';
    if (!groups[g]) groups[g] = [];
    groups[g].push(item);
  }
  const sortedGroups = Object.keys(groups).sort((a, b) => {
    if (a === '(No Group)') return 1;
    if (b === '(No Group)') return -1;
    return a.localeCompare(b);
  });

  let html = '';
  for (const g of sortedGroups) {
    html += `<div class="group-header">${escHtml(g)}</div>`;
    for (const item of groups[g].sort((a, b) => (a.rec.title || '').localeCompare(b.rec.title || ''))) {
      const active = item.idx === appState.selectedIdx ? ' active' : '';
      html += `<div class="entry-item${active}" data-idx="${item.idx}">
        <div class="entry-title">${escHtml(item.rec.title || 'Untitled')}</div>
        <div class="entry-user">${escHtml(item.rec.username || '')}</div>
      </div>`;
    }
  }
  if (!items.length) html = '<div style="padding:20px;color:#999;text-align:center">No entries found</div>';
  entryListEl.innerHTML = html;

  entryListEl.querySelectorAll('.entry-item').forEach(el => {
    el.addEventListener('click', () => {
      appState.selectedIdx = parseInt(el.dataset.idx);
      appState.editing = false;
      renderEntryList();
      renderDetail();
    });
  });
}

function renderDetail() {
  if (appState.selectedIdx < 0 || appState.selectedIdx >= appState.vault.records.length) {
    entryDetailEl.innerHTML = '<div class="empty-state">Select an entry or create a new one</div>';
    return;
  }

  const rec = appState.vault.records[appState.selectedIdx];
  const ed = appState.editing;
  const ro = ed ? '' : 'readonly';

  entryDetailEl.innerHTML = `
    <div class="detail-card">
      <h2>${ed ? 'Edit Entry' : escHtml(rec.title || 'Untitled')}</h2>
      <div class="field-row"><label>Title</label>
        <div class="field-value"><input type="text" id="f-title" value="${escAttr(rec.title)}" ${ro}></div>
      </div>
      <div class="field-row"><label>Group</label>
        <div class="field-value"><input type="text" id="f-group" value="${escAttr(rec.group)}" ${ro}></div>
      </div>
      <div class="field-row"><label>Username</label>
        <div class="field-value">
          <input type="text" id="f-user" value="${escAttr(rec.username)}" ${ro}>
          <button class="btn-icon" title="Copy" onclick="copyText(document.getElementById('f-user').value)">&#128203;</button>
        </div>
      </div>
      <div class="field-row"><label>Password</label>
        <div class="field-value">
          <input type="password" id="f-pass" class="password-field" value="${escAttr(rec.password)}" ${ro}>
          <button class="btn-icon" id="btn-toggle-pw" title="Show/Hide">&#128065;</button>
          <button class="btn-icon" title="Copy" onclick="copyText(document.getElementById('f-pass').value)">&#128203;</button>
        </div>
      </div>
      <div class="field-row"><label>URL</label>
        <div class="field-value">
          <input type="text" id="f-url" value="${escAttr(rec.url)}" ${ro}>
          <button class="btn-icon" title="Copy" onclick="copyText(document.getElementById('f-url').value)">&#128203;</button>
        </div>
      </div>
      <div class="field-row"><label>Email</label>
        <div class="field-value"><input type="text" id="f-email" value="${escAttr(rec.email)}" ${ro}></div>
      </div>
      <div class="field-row"><label>Notes</label>
        <textarea id="f-notes" ${ro}>${escHtml(rec.notes)}</textarea>
      </div>
      <div class="timestamp">Created: ${formatTime(rec.ctime)} | Modified: ${formatTime(rec.mtime)}</div>
      <div class="detail-actions">
        ${ed ? `
          <button class="btn btn-primary" id="btn-save-entry">Save</button>
          <button class="btn btn-secondary" id="btn-cancel-edit">Cancel</button>
          <button class="btn btn-danger" id="btn-delete-entry">Delete</button>
        ` : `
          <button class="btn btn-primary" id="btn-edit-entry">Edit</button>
          <button class="btn btn-danger" id="btn-delete-entry">Delete</button>
        `}
      </div>
    </div>
  `;

  // Toggle password visibility
  $('btn-toggle-pw').addEventListener('click', () => {
    const f = $('f-pass');
    f.type = f.type === 'password' ? 'text' : 'password';
  });

  if (ed) {
    $('btn-save-entry').addEventListener('click', () => {
      rec.title = $('f-title').value;
      rec.group = $('f-group').value;
      rec.username = $('f-user').value;
      rec.password = $('f-pass').value;
      rec.url = $('f-url').value;
      rec.email = $('f-email').value;
      rec.notes = $('f-notes').value;
      rec.mtime = Math.floor(Date.now() / 1000);
      if (!rec.pmtime && rec.password) rec.pmtime = rec.mtime;
      appState.editing = false;
      appState.modified = true;
      renderEntryList();
      renderDetail();
      showToast('Entry updated');
    });
    $('btn-cancel-edit').addEventListener('click', () => {
      appState.editing = false;
      renderDetail();
    });
  } else {
    $('btn-edit-entry').addEventListener('click', () => {
      appState.editing = true;
      renderDetail();
    });
  }

  $('btn-delete-entry').addEventListener('click', () => {
    const close = showModal(`
      <h3>Delete Entry?</h3>
      <p>Are you sure you want to delete "${escHtml(rec.title)}"?</p>
      <div class="btn-row" style="margin-top:20px">
        <button class="btn btn-danger" id="confirm-delete">Delete</button>
        <button class="btn btn-secondary" id="cancel-delete">Cancel</button>
      </div>
    `);
    $('cancel-delete').onclick = close;
    $('confirm-delete').onclick = () => {
      appState.vault.records.splice(appState.selectedIdx, 1);
      appState.selectedIdx = -1;
      appState.modified = true;
      close();
      renderEntryList();
      renderDetail();
      showToast('Entry deleted');
    };
  });
}

// Search
searchBox.addEventListener('input', () => {
  renderEntryList();
});

// Add new entry
$('btn-add').addEventListener('click', () => {
  const uuid = new Uint8Array(16);
  crypto.getRandomValues(uuid);
  uuid[6] = (uuid[6] & 0x0F) | 0x40;
  uuid[8] = (uuid[8] & 0x3F) | 0x80;
  const newRec = {
    uuid, group: '', title: 'New Entry', username: '', password: '', notes: '',
    url: '', email: '', autotype: '', runCmd: '', symbols: '', policyName: '',
    ctime: Math.floor(Date.now() / 1000), pmtime: 0, atime: 0, exptime: 0,
    mtime: Math.floor(Date.now() / 1000), protected: false, rawFields: []
  };
  appState.vault.records.push(newRec);
  appState.selectedIdx = appState.vault.records.length - 1;
  appState.editing = true;
  appState.modified = true;
  renderEntryList();
  renderDetail();
});

// Save vault
$('btn-save').addEventListener('click', async () => {
  if (!appState.vault || !appState.password) return;
  try {
    showToast('Saving...');
    const fileData = await saveVault(
      appState.vault.header,
      appState.vault.records,
      appState.password,
      appState.vault.iter
    );
    const blob = new Blob([fileData], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = appState.fileName || 'vault.psafe3';
    a.click();
    URL.revokeObjectURL(url);
    appState.modified = false;
    showToast('Vault saved (verified)');
  } catch (e) {
    showToast('Save failed: ' + e.message);
  }
});

// Lock vault
$('btn-lock').addEventListener('click', () => {
  if (appState.modified) {
    const close = showModal(`
      <h3>Unsaved Changes</h3>
      <p>You have unsaved changes. Lock anyway?</p>
      <div class="btn-row" style="margin-top:20px">
        <button class="btn btn-danger" id="confirm-lock">Lock</button>
        <button class="btn btn-secondary" id="cancel-lock">Cancel</button>
      </div>
    `);
    $('cancel-lock').onclick = close;
    $('confirm-lock').onclick = () => { close(); showOpenScreen(); };
  } else {
    showOpenScreen();
  }
});

// HTML escaping helpers
function escHtml(s) { return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }
function escAttr(s) { return String(s||'').replace(/&/g,'&amp;').replace(/"/g,'&quot;').replace(/'/g,'&#39;'); }

// =====================================================================
// INITIALIZATION
// =====================================================================

(function init() {
  const selfTest = twofishSelfTest();
  if (selfTest !== true) {
    showStatus('CRITICAL: Twofish self-test failed (' + selfTest + '). This browser may not be supported.', 'error');
    btnOpen.disabled = true;
    btnNew.disabled = true;
  }
})();

</script>
</body>
</html>

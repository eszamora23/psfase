<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="Content-Security-Policy" content="default-src 'none'; script-src 'unsafe-inline'; style-src 'unsafe-inline'; img-src data:;">
<title>Password Safe</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;background:#f0f2f5;color:#1a1a2e;min-height:100vh}
.hidden{display:none!important}
/* Open Screen */
#screen-open{display:flex;align-items:center;justify-content:center;min-height:100vh;padding:20px}
.open-card{background:#fff;border-radius:12px;padding:40px;width:100%;max-width:620px;box-shadow:0 2px 20px rgba(0,0,0,.08)}
.open-card h1{font-size:24px;margin-bottom:8px;color:#1a1a2e}
.open-card .subtitle{color:#666;font-size:14px;margin-bottom:28px}
.form-group{margin-bottom:20px}
.form-group label{display:block;font-size:13px;font-weight:600;color:#444;margin-bottom:6px}
.form-group input[type=file]{width:100%;padding:10px;border:2px dashed #d0d5dd;border-radius:8px;background:#fafafa;cursor:pointer;font-size:13px}
.form-group input[type=password],.form-group input[type=text]{width:100%;padding:10px 12px;border:1px solid #d0d5dd;border-radius:8px;font-size:14px;outline:none;transition:border .2s}
.form-group input:focus{border-color:#4a6cf7}
.btn{padding:10px 20px;border:none;border-radius:8px;font-size:14px;font-weight:600;cursor:pointer;transition:all .2s}
.btn:disabled{opacity:.5;cursor:not-allowed}
.btn-primary{background:#4a6cf7;color:#fff;width:100%}
.btn-primary:hover:not(:disabled){background:#3b5de7}
.btn-secondary{background:#e8ecf1;color:#444}
.btn-secondary:hover{background:#d0d5dd}
.btn-danger{background:#ef4444;color:#fff}
.btn-danger:hover{background:#dc2626}
.btn-sm{padding:6px 12px;font-size:12px}
.btn-row{display:flex;gap:10px;margin-top:20px}
.btn-row .btn{flex:1}
#status{margin-top:16px;font-size:13px;text-align:center;min-height:20px}
.status-error{color:#ef4444}
.status-ok{color:#22c55e}
.status-info{color:#4a6cf7}
/* Vault Screen */
#screen-vault{display:flex;flex-direction:column;height:100vh}
.toolbar{background:#fff;border-bottom:1px solid #e5e7eb;padding:10px 20px;display:flex;align-items:center;gap:12px;flex-shrink:0}
.toolbar .vault-name{font-weight:700;font-size:16px;margin-right:auto}
.toolbar input[type=search]{padding:8px 12px;border:1px solid #d0d5dd;border-radius:8px;font-size:13px;width:220px;outline:none}
.toolbar input[type=search]:focus{border-color:#4a6cf7}
.vault-body{display:flex;flex:1;overflow:hidden}
.entry-list{width:340px;border-right:1px solid #e5e7eb;overflow-y:auto;background:#fff;flex-shrink:0}
.group-header{padding:8px 16px;font-size:11px;font-weight:700;text-transform:uppercase;color:#888;background:#f7f8fa;border-bottom:1px solid #eee;position:sticky;top:0}
.entry-item{padding:12px 16px;border-bottom:1px solid #f0f0f0;cursor:pointer;transition:background .15s}
.entry-item:hover{background:#f0f4ff}
.entry-item.active{background:#e8edff;border-left:3px solid #4a6cf7}
.entry-item .entry-title{font-weight:600;font-size:14px}
.entry-item .entry-user{font-size:12px;color:#666;margin-top:2px}
.entry-detail{flex:1;overflow-y:auto;padding:24px;background:#f7f8fa}
.detail-card{background:#fff;border-radius:10px;padding:24px;max-width:600px;box-shadow:0 1px 4px rgba(0,0,0,.06)}
.detail-card h2{font-size:20px;margin-bottom:20px}
.field-row{margin-bottom:16px}
.field-row label{display:block;font-size:12px;font-weight:600;color:#888;margin-bottom:4px;text-transform:uppercase}
.field-row .field-value{display:flex;align-items:center;gap:8px}
.field-row input,.field-row textarea{flex:1;padding:8px 10px;border:1px solid #d0d5dd;border-radius:6px;font-size:14px;font-family:inherit;outline:none}
.field-row input:focus,.field-row textarea:focus{border-color:#4a6cf7}
.field-row input[readonly],.field-row textarea[readonly]{background:#f9fafb;border-color:#eee;color:#555}
.field-row textarea{resize:vertical;min-height:80px}
.field-row .password-field{font-family:'Courier New',monospace}
.btn-icon{background:none;border:1px solid #d0d5dd;border-radius:6px;padding:7px 10px;cursor:pointer;font-size:13px;color:#555;transition:all .15s}
.btn-icon:hover{background:#f0f4ff;border-color:#4a6cf7;color:#4a6cf7}
.detail-actions{display:flex;gap:10px;margin-top:24px;padding-top:16px;border-top:1px solid #eee}
.empty-state{display:flex;align-items:center;justify-content:center;flex:1;color:#999;font-size:15px}
.toast{position:fixed;bottom:20px;right:20px;background:#1a1a2e;color:#fff;padding:10px 20px;border-radius:8px;font-size:13px;z-index:100;animation:fadeIn .2s}
@keyframes fadeIn{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}
.modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.4);display:flex;align-items:center;justify-content:center;z-index:50}
.modal{background:#fff;border-radius:12px;padding:28px;width:90%;max-width:400px;box-shadow:0 4px 30px rgba(0,0,0,.15)}
.modal h3{margin-bottom:16px;font-size:18px}
.timestamp{font-size:12px;color:#999;margin-top:4px}
</style>
</head>
<body>

<!-- OPEN SCREEN -->
<div id="screen-open">
<div class="open-card">
  <h1>Password Safe</h1>
  <p class="subtitle">Local .psafe3 vault viewer &amp; editor <span style="color:#ccc;font-size:11px">v3</span></p>
  <div class="form-group">
    <label>Vault File (.psafe3)</label>
    <input type="file" id="file-input" accept=".psafe3,.dat">
  </div>
  <div class="form-group">
    <label>Master Password</label>
    <input type="password" id="master-password" placeholder="Enter master password" autocomplete="off">
  </div>
  <div class="btn-row">
    <button class="btn btn-primary" id="btn-open" disabled>Unlock</button>
    <button class="btn btn-secondary" id="btn-new">New Vault</button>
  </div>
  <div id="status"></div>
</div>
</div>

<!-- VAULT SCREEN -->
<div id="screen-vault" class="hidden">
<div class="toolbar">
  <span class="vault-name" id="vault-name">Vault</span>
  <input type="search" id="search-box" placeholder="Search entries...">
  <button class="btn btn-secondary btn-sm" id="btn-add">+ New</button>
  <button class="btn btn-primary btn-sm" id="btn-save">Save</button>
  <button class="btn btn-secondary btn-sm" id="btn-lock">Lock</button>
</div>
<div class="vault-body">
  <div class="entry-list" id="entry-list"></div>
  <div class="entry-detail" id="entry-detail">
    <div class="empty-state">Select an entry or create a new one</div>
  </div>
</div>
</div>

<!-- MODAL (reusable) -->
<div id="modal-overlay" class="modal-overlay hidden">
<div class="modal" id="modal-content"></div>
</div>

<script>
'use strict';

// =====================================================================
// TWOFISH BLOCK CIPHER - Pure JavaScript Implementation
// =====================================================================

const Q0 = new Uint8Array([
  0xA9,0x67,0xB3,0xE8,0x04,0xFD,0xA3,0x76,0x9A,0x92,0x80,0x78,0xE4,0xDD,0xD1,0x38,
  0x0D,0xC6,0x35,0x98,0x18,0xF7,0xEC,0x6C,0x43,0x75,0x37,0x26,0xFA,0x13,0x94,0x48,
  0xF2,0xD0,0x8B,0x30,0x84,0x54,0xDF,0x23,0x19,0x5B,0x3D,0x59,0xF3,0xAE,0xA2,0x82,
  0x63,0x01,0x83,0x2E,0xD9,0x51,0x9B,0x7C,0xA6,0xEB,0xA5,0xBE,0x16,0x0C,0xE3,0x61,
  0xC0,0x8C,0x3A,0xF5,0x73,0x2C,0x25,0x0B,0xBB,0x4E,0x89,0x6B,0x53,0x6A,0xB4,0xF1,
  0xE1,0xE6,0xBD,0x45,0xE2,0xF4,0xB6,0x66,0xCC,0x95,0x03,0x56,0xD4,0x1C,0x1E,0xD7,
  0xFB,0xC3,0x8E,0xB5,0xE9,0xCF,0xBF,0xBA,0xEA,0x77,0x39,0xAF,0x33,0xC9,0x62,0x71,
  0x81,0x79,0x09,0xAD,0x24,0xCD,0xF9,0xD8,0xE5,0xC5,0xB9,0x4D,0x44,0x08,0x86,0xE7,
  0xA1,0x1D,0xAA,0xED,0x06,0x70,0xB2,0xD2,0x41,0x7B,0xA0,0x11,0x31,0xC2,0x27,0x90,
  0x20,0xF6,0x60,0xFF,0x96,0x5C,0xB1,0xAB,0x9E,0x9C,0x52,0x1B,0x5F,0x93,0x0A,0xEF,
  0x91,0x85,0x49,0xEE,0x2D,0x4F,0x8F,0x3B,0x47,0x87,0x6D,0x46,0xD6,0x3E,0x69,0x64,
  0x2A,0xCE,0xCB,0x2F,0xFC,0x97,0x05,0x7A,0xAC,0x7F,0xD5,0x1A,0x4B,0x0E,0xA7,0x5A,
  0x28,0x14,0x3F,0x29,0x88,0x3C,0x4C,0x02,0xB8,0xDA,0xB0,0x17,0x55,0x1F,0x8A,0x7D,
  0x57,0xC7,0x8D,0x74,0xB7,0xC4,0x9F,0x72,0x7E,0x15,0x22,0x12,0x58,0x07,0x99,0x34,
  0x6E,0x50,0xDE,0x68,0x65,0xBC,0xDB,0xF8,0xC8,0xA8,0x2B,0x40,0xDC,0xFE,0x32,0xA4,
  0xCA,0x10,0x21,0xF0,0xD3,0x5D,0x0F,0x00,0x6F,0x9D,0x36,0x42,0x4A,0x5E,0xC1,0xE0
]);

const Q1 = new Uint8Array([
  0x75,0xF3,0xC6,0xF4,0xDB,0x7B,0xFB,0xC8,0x4A,0xD3,0xE6,0x6B,0x45,0x7D,0xE8,0x4B,
  0xD6,0x32,0xD8,0xFD,0x37,0x71,0xF1,0xE1,0x30,0x0F,0xF8,0x1B,0x87,0xFA,0x06,0x3F,
  0x5E,0xBA,0xAE,0x5B,0x8A,0x00,0xBC,0x9D,0x6D,0xC1,0xB1,0x0E,0x80,0x5D,0xD2,0xD5,
  0xA0,0x84,0x07,0x14,0xB5,0x90,0x2C,0xA3,0xB2,0x73,0x4C,0x54,0x92,0x74,0x36,0x51,
  0x38,0xB0,0xBD,0x5A,0xFC,0x60,0x62,0x96,0x6C,0x42,0xF7,0x10,0x7C,0x28,0x27,0x8C,
  0x13,0x95,0x9C,0xC7,0x24,0x46,0x3B,0x70,0xCA,0xE3,0x85,0xCB,0x11,0xD0,0x93,0xB8,
  0xA6,0x83,0x20,0xFF,0x9F,0x77,0xC3,0xCC,0x03,0x6F,0x08,0xBF,0x40,0xE7,0x2B,0xE2,
  0x79,0x0C,0xAA,0x82,0x41,0x3A,0xEA,0xB9,0xE4,0x9A,0xA4,0x97,0x7E,0xDA,0x7A,0x17,
  0x66,0x94,0xA1,0x1D,0x3D,0xF0,0xDE,0xB3,0x0B,0x72,0xA7,0x1C,0xEF,0xD1,0x53,0x3E,
  0x8F,0x33,0x26,0x5F,0xEC,0x76,0x2A,0x49,0x81,0x88,0xEE,0x21,0xC4,0x1A,0xEB,0xD9,
  0xC5,0x39,0x99,0xCD,0xAD,0x31,0x8B,0x01,0x18,0x23,0xDD,0x1F,0x4E,0x2D,0xF9,0x48,
  0x4F,0xF2,0x65,0x8E,0x78,0x5C,0x58,0x19,0x8D,0xE5,0x98,0x57,0x67,0x7F,0x05,0x64,
  0xAF,0x63,0xB6,0xFE,0xF5,0xB7,0x3C,0xA5,0xCE,0xE9,0x68,0x44,0xE0,0x4D,0x43,0x69,
  0x29,0x2E,0xAC,0x15,0x59,0xA8,0x0A,0x9E,0x6E,0x47,0xDF,0x34,0x35,0x6A,0xCF,0xDC,
  0x22,0xC9,0xC0,0x9B,0x89,0xD4,0xED,0xAB,0x12,0xA2,0x0D,0x52,0xBB,0x02,0x2F,0xA9,
  0xD7,0x61,0x1E,0xB4,0x50,0x04,0xF6,0xC2,0x16,0x25,0x86,0x56,0x55,0x09,0xBE,0x91
]);

// RS matrix (4x8) for key schedule - GF(2^8) poly 0x14D
const RS = [
  [0x01,0xA4,0x55,0x87,0x5A,0x58,0xDB,0x9E],
  [0xA4,0x56,0x82,0xF3,0x1E,0xC6,0x68,0xE5],
  [0x02,0xA1,0xFC,0xC1,0x47,0xAE,0x3D,0x19],
  [0xA4,0x55,0x87,0x5A,0x58,0xDB,0x9E,0x03]
];

// GF(2^8) multiply with polynomial 0x14D (for RS)
function gfMul14D(a, b) {
  let r = 0, aa = a;
  for (let i = 0; i < 8; i++) {
    if (b & (1 << i)) r ^= aa;
    const hi = aa & 0x80;
    aa = (aa << 1) & 0xFF;
    if (hi) aa ^= 0x4D;
  }
  return r;
}

// GF(2^8) multiply with polynomial 0x169 (for MDS)
function gfMul169(a, b) {
  let r = 0, aa = a;
  for (let i = 0; i < 8; i++) {
    if (b & (1 << i)) r ^= aa;
    const hi = aa & 0x80;
    aa = (aa << 1) & 0xFF;
    if (hi) aa ^= 0x69;
  }
  return r;
}

// Precompute MDS lookup tables (column contributions)
// MDS matrix:
// [0x01, 0xEF, 0x5B, 0x5B]
// [0x5B, 0xEF, 0xEF, 0x01]
// [0xEF, 0x5B, 0x01, 0xEF]
// [0xEF, 0x01, 0xEF, 0x5B]
const MDS0 = new Uint32Array(256);
const MDS1 = new Uint32Array(256);
const MDS2 = new Uint32Array(256);
const MDS3 = new Uint32Array(256);

for (let i = 0; i < 256; i++) {
  const m = (a, b) => gfMul169(a, b);
  MDS0[i] = ((m(0x01,i)) | (m(0x5B,i)<<8) | (m(0xEF,i)<<16) | (m(0xEF,i)<<24)) >>> 0;
  MDS1[i] = ((m(0xEF,i)) | (m(0xEF,i)<<8) | (m(0x5B,i)<<16) | (m(0x01,i)<<24)) >>> 0;
  MDS2[i] = ((m(0x5B,i)) | (m(0xEF,i)<<8) | (m(0x01,i)<<16) | (m(0xEF,i)<<24)) >>> 0;
  MDS3[i] = ((m(0x5B,i)) | (m(0x01,i)<<8) | (m(0xEF,i)<<16) | (m(0x5B,i)<<24)) >>> 0;
}

// Helper: read/write 32-bit LE
function rU32(b, o) { return (b[o] | (b[o+1]<<8) | (b[o+2]<<16) | (b[o+3]<<24)) >>> 0; }
function wU32(b, o, v) { b[o]=v&0xFF; b[o+1]=(v>>>8)&0xFF; b[o+2]=(v>>>16)&0xFF; b[o+3]=(v>>>24)&0xFF; }

// Rotate left/right 32-bit
function ROL(x, n) { return ((x << n) | (x >>> (32 - n))) >>> 0; }
function ROR(x, n) { return ((x >>> n) | (x << (32 - n))) >>> 0; }

// RS matrix multiply: 8 bytes -> 4 bytes
function rsRemix(src, off) {
  const out = new Uint8Array(4);
  for (let i = 0; i < 4; i++) {
    let v = 0;
    for (let j = 0; j < 8; j++) v ^= gfMul14D(RS[i][j], src[off + j]);
    out[i] = v;
  }
  return out;
}

// h function: core of Twofish key schedule and g function
// x: 32-bit word, L: array of 4 uint32 words (used in reverse order: L[3] outermost)
// q-permutation table for 256-bit key (per byte position):
//   byte 0: q1 → xor L3 → q1 → xor L2 → q0 → xor L1 → q0 → xor L0 → q1 → MDS
//   byte 1: q0 → xor L3 → q1 → xor L2 → q1 → xor L1 → q0 → xor L0 → q0 → MDS
//   byte 2: q0 → xor L3 → q0 → xor L2 → q0 → xor L1 → q1 → xor L0 → q1 → MDS
//   byte 3: q1 → xor L3 → q0 → xor L2 → q1 → xor L1 → q1 → xor L0 → q0 → MDS
function hFunc(x, L) {
  let b0 = x & 0xFF, b1 = (x>>>8) & 0xFF, b2 = (x>>>16) & 0xFF, b3 = (x>>>24) & 0xFF;
  // Stage 1 (outermost, XOR with L[3])
  b0 = Q1[b0] ^ (L[3] & 0xFF);
  b1 = Q0[b1] ^ ((L[3]>>>8) & 0xFF);
  b2 = Q0[b2] ^ ((L[3]>>>16) & 0xFF);
  b3 = Q1[b3] ^ ((L[3]>>>24) & 0xFF);
  // Stage 2 (XOR with L[2])
  b0 = Q1[b0] ^ (L[2] & 0xFF);
  b1 = Q1[b1] ^ ((L[2]>>>8) & 0xFF);
  b2 = Q0[b2] ^ ((L[2]>>>16) & 0xFF);
  b3 = Q0[b3] ^ ((L[2]>>>24) & 0xFF);
  // Stage 3 (XOR with L[1])
  b0 = Q0[b0] ^ (L[1] & 0xFF);
  b1 = Q1[b1] ^ ((L[1]>>>8) & 0xFF);
  b2 = Q0[b2] ^ ((L[1]>>>16) & 0xFF);
  b3 = Q1[b3] ^ ((L[1]>>>24) & 0xFF);
  // Stage 4 (XOR with L[0])
  b0 = Q0[b0] ^ (L[0] & 0xFF);
  b1 = Q0[b1] ^ ((L[0]>>>8) & 0xFF);
  b2 = Q1[b2] ^ ((L[0]>>>16) & 0xFF);
  b3 = Q1[b3] ^ ((L[0]>>>24) & 0xFF);
  // Final q (no XOR)
  b0 = Q1[b0]; b1 = Q0[b1]; b2 = Q1[b2]; b3 = Q0[b3];
  // MDS
  return (MDS0[b0] ^ MDS1[b1] ^ MDS2[b2] ^ MDS3[b3]) >>> 0;
}

// Initialize Twofish for a 256-bit key
function twofishInit(key) {
  // key: Uint8Array(32)
  // Compute Me (even 32-bit words) and Mo (odd 32-bit words)
  const Me = [rU32(key,0), rU32(key,8), rU32(key,16), rU32(key,24)];
  const Mo = [rU32(key,4), rU32(key,12), rU32(key,20), rU32(key,28)];

  // Compute S-box keys via RS matrix
  const s0 = rsRemix(key, 0);
  const s1 = rsRemix(key, 8);
  const s2 = rsRemix(key, 16);
  const s3 = rsRemix(key, 24);

  // Compute 40 subkeys
  const subKeys = new Uint32Array(40);
  for (let i = 0; i < 20; i++) {
    const byteA = 2 * i, byteB = 2 * i + 1;
    const xA = (byteA | (byteA<<8) | (byteA<<16) | (byteA<<24)) >>> 0;
    const xB = (byteB | (byteB<<8) | (byteB<<16) | (byteB<<24)) >>> 0;
    const a = hFunc(xA, Me);
    const b = ROL(hFunc(xB, Mo), 8);
    subKeys[2*i] = (a + b) >>> 0;
    subKeys[2*i+1] = ROL((a + 2*b) >>> 0, 9);
  }

  // Precompute key-dependent S-box tables (g function = 4 lookups + 3 XORs)
  // Uses same q-permutation chain as h function but with RS-derived S-box keys
  const sBox = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
  for (let i = 0; i < 256; i++) {
    // Byte 0: q1 → s3 → q1 → s2 → q0 → s1 → q0 → s0 → q1 → MDS
    sBox[0][i] = MDS0[Q1[Q0[Q0[Q1[Q1[i]^s3[0]]^s2[0]]^s1[0]]^s0[0]]];
    // Byte 1: q0 → s3 → q1 → s2 → q1 → s1 → q0 → s0 → q0 → MDS
    sBox[1][i] = MDS1[Q0[Q0[Q1[Q1[Q0[i]^s3[1]]^s2[1]]^s1[1]]^s0[1]]];
    // Byte 2: q0 → s3 → q0 → s2 → q0 → s1 → q1 → s0 → q1 → MDS
    sBox[2][i] = MDS2[Q1[Q1[Q0[Q0[Q0[i]^s3[2]]^s2[2]]^s1[2]]^s0[2]]];
    // Byte 3: q1 → s3 → q0 → s2 → q1 → s1 → q1 → s0 → q0 → MDS
    sBox[3][i] = MDS3[Q0[Q1[Q1[Q0[Q1[i]^s3[3]]^s2[3]]^s1[3]]^s0[3]]];
  }

  return { subKeys, sBox };
}

// g function: key-dependent permutation
function gFunc(x, sBox) {
  return (sBox[0][x & 0xFF] ^ sBox[1][(x>>>8)&0xFF] ^ sBox[2][(x>>>16)&0xFF] ^ sBox[3][(x>>>24)&0xFF]) >>> 0;
}

// Encrypt a single 16-byte block
function twofishEncryptBlock(block, ctx) {
  let r0 = rU32(block,0) ^ ctx.subKeys[0];
  let r1 = rU32(block,4) ^ ctx.subKeys[1];
  let r2 = rU32(block,8) ^ ctx.subKeys[2];
  let r3 = rU32(block,12) ^ ctx.subKeys[3];

  for (let round = 0; round < 16; round++) {
    const t0 = gFunc(r0, ctx.sBox);
    const t1 = gFunc(ROL(r1, 8), ctx.sBox);
    const f0 = (t0 + t1 + ctx.subKeys[2*round+8]) >>> 0;
    const f1 = (t0 + 2*t1 + ctx.subKeys[2*round+9]) >>> 0;
    r2 = ROR(r2 ^ f0, 1);
    r3 = ROL(r3, 1) ^ f1;
    let tmp;
    tmp = r0; r0 = r2; r2 = tmp;
    tmp = r1; r1 = r3; r3 = tmp;
  }
  // Undo last swap
  let tmp;
  tmp = r0; r0 = r2; r2 = tmp;
  tmp = r1; r1 = r3; r3 = tmp;

  const out = new Uint8Array(16);
  wU32(out, 0, (r0 ^ ctx.subKeys[4]) >>> 0);
  wU32(out, 4, (r1 ^ ctx.subKeys[5]) >>> 0);
  wU32(out, 8, (r2 ^ ctx.subKeys[6]) >>> 0);
  wU32(out, 12, (r3 ^ ctx.subKeys[7]) >>> 0);
  return out;
}

// Decrypt a single 16-byte block
function twofishDecryptBlock(block, ctx) {
  let r0 = rU32(block,0) ^ ctx.subKeys[4];
  let r1 = rU32(block,4) ^ ctx.subKeys[5];
  let r2 = rU32(block,8) ^ ctx.subKeys[6];
  let r3 = rU32(block,12) ^ ctx.subKeys[7];

  for (let round = 15; round >= 0; round--) {
    const t0 = gFunc(r0, ctx.sBox);
    const t1 = gFunc(ROL(r1, 8), ctx.sBox);
    const f0 = (t0 + t1 + ctx.subKeys[2*round+8]) >>> 0;
    const f1 = (t0 + 2*t1 + ctx.subKeys[2*round+9]) >>> 0;
    r2 = ROL(r2, 1) ^ f0;
    r3 = ROR(r3 ^ f1, 1);
    let tmp;
    tmp = r0; r0 = r2; r2 = tmp;
    tmp = r1; r1 = r3; r3 = tmp;
  }
  // Undo last swap
  let tmp;
  tmp = r0; r0 = r2; r2 = tmp;
  tmp = r1; r1 = r3; r3 = tmp;

  const out = new Uint8Array(16);
  wU32(out, 0, (r0 ^ ctx.subKeys[0]) >>> 0);
  wU32(out, 4, (r1 ^ ctx.subKeys[1]) >>> 0);
  wU32(out, 8, (r2 ^ ctx.subKeys[2]) >>> 0);
  wU32(out, 12, (r3 ^ ctx.subKeys[3]) >>> 0);
  return out;
}

// Self-test with known test vector
function twofishSelfTest() {
  const key = new Uint8Array(32); // all zeros
  const pt = new Uint8Array(16);  // all zeros
  const expected = new Uint8Array([0x57,0xFF,0x73,0x9D,0x4D,0xC9,0x2C,0x1B,0xD7,0xFC,0x01,0x70,0x0C,0xC8,0x21,0x6F]);
  const ctx = twofishInit(key);
  const ct = twofishEncryptBlock(pt, ctx);
  for (let i = 0; i < 16; i++) {
    if (ct[i] !== expected[i]) return false;
  }
  const dec = twofishDecryptBlock(ct, ctx);
  for (let i = 0; i < 16; i++) {
    if (dec[i] !== pt[i]) return false;
  }
  return true;
}

// =====================================================================
// CBC MODE
// =====================================================================

function cbcDecrypt(data, ctx, iv) {
  const blocks = data.length / 16;
  const out = new Uint8Array(data.length);
  let prevCt = iv;
  for (let i = 0; i < blocks; i++) {
    const off = i * 16;
    const ctBlock = data.slice(off, off + 16);
    const ptBlock = twofishDecryptBlock(ctBlock, ctx);
    for (let j = 0; j < 16; j++) out[off + j] = ptBlock[j] ^ prevCt[j];
    prevCt = ctBlock;
  }
  return out;
}

function cbcEncrypt(data, ctx, iv) {
  const blocks = data.length / 16;
  const out = new Uint8Array(data.length);
  let prev = iv;
  for (let i = 0; i < blocks; i++) {
    const off = i * 16;
    const xored = new Uint8Array(16);
    for (let j = 0; j < 16; j++) xored[j] = data[off + j] ^ prev[j];
    const ctBlock = twofishEncryptBlock(xored, ctx);
    out.set(ctBlock, off);
    prev = ctBlock;
  }
  return out;
}

// =====================================================================
// CRYPTO HELPERS (Web Crypto API)
// =====================================================================

async function sha256(data) {
  const buf = await crypto.subtle.digest('SHA-256', data);
  return new Uint8Array(buf);
}

async function hmacSha256(key, data) {
  const cryptoKey = await crypto.subtle.importKey('raw', key, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
  const sig = await crypto.subtle.sign('HMAC', cryptoKey, data);
  return new Uint8Array(sig);
}

async function stretchKey(password, salt, iterations) {
  const encoder = new TextEncoder();
  const passBytes = encoder.encode(password);
  const combined = new Uint8Array(passBytes.length + salt.length);
  combined.set(passBytes);
  combined.set(salt, passBytes.length);
  let hash = await sha256(combined);
  for (let i = 0; i < iterations; i++) {
    hash = await sha256(hash);
  }
  return hash;
}

// =====================================================================
// PSAFE3 FORMAT PARSER & WRITER
// =====================================================================

const TAG = new Uint8Array([0x50, 0x57, 0x53, 0x33]); // "PWS3"
const EOF_MARKER = new TextEncoder().encode('PWS3-EOFPWS3-EOF');

// Header field types
const HDR_VERSION = 0x00;
const HDR_UUID = 0x01;
const HDR_PREFS = 0x02;
const HDR_TREE = 0x03;
const HDR_SAVE_TIME = 0x04;
const HDR_SAVE_WHO = 0x05;
const HDR_SAVE_WHAT = 0x06;
const HDR_SAVE_USER = 0x07;
const HDR_SAVE_HOST = 0x08;
const HDR_DB_NAME = 0x09;
const HDR_DB_DESC = 0x0A;
const HDR_END = 0xFF;

// Record field types
const REC_UUID = 0x01;
const REC_GROUP = 0x02;
const REC_TITLE = 0x03;
const REC_USER = 0x04;
const REC_NOTES = 0x05;
const REC_PASSWORD = 0x06;
const REC_CTIME = 0x07;
const REC_PMTIME = 0x08;
const REC_ATIME = 0x09;
const REC_EXPTIME = 0x0A;
const REC_MTIME = 0x0C;
const REC_URL = 0x0D;
const REC_AUTOTYPE = 0x0E;
const REC_PWHIST = 0x0F;
const REC_POLICY = 0x10;
const REC_XINT = 0x11;
const REC_RUNCMD = 0x12;
const REC_EMAIL = 0x14;
const REC_PROTECTED = 0x15;
const REC_SYMBOLS = 0x16;
const REC_POLICYNAME = 0x18;
const REC_KBSHORTCUT = 0x19;
const REC_END = 0xFF;

const textDec = new TextDecoder('utf-8');

function parseFields(plaintext) {
  const fields = [];
  let offset = 0;
  while (offset + 5 <= plaintext.length) {
    const dataLen = rU32(plaintext, offset);
    const type = plaintext[offset + 4];
    const rawSize = 5 + dataLen;
    const paddedSize = Math.ceil(rawSize / 16) * 16;
    if (offset + paddedSize > plaintext.length) break;
    const data = plaintext.slice(offset + 5, offset + 5 + dataLen);
    fields.push({ type, data });
    offset += paddedSize;
  }
  return fields;
}

function readText(data) { return textDec.decode(data); }
function readTime(data) { return data.length >= 4 ? rU32(data, 0) : 0; }
function readU16(data) { return data.length >= 2 ? (data[0] | (data[1] << 8)) : 0; }

function fieldsToHeader(fields) {
  const hdr = { version: 0x030D, uuid: null, dbName: '', dbDesc: '', prefs: '', tree: '',
    saveTime: 0, saveWho: '', saveWhat: '', saveUser: '', saveHost: '', rawFields: [] };
  for (const f of fields) {
    hdr.rawFields.push(f);
    switch (f.type) {
      case HDR_VERSION: hdr.version = readU16(f.data); break;
      case HDR_UUID: hdr.uuid = new Uint8Array(f.data); break;
      case HDR_DB_NAME: hdr.dbName = readText(f.data); break;
      case HDR_DB_DESC: hdr.dbDesc = readText(f.data); break;
      case HDR_PREFS: hdr.prefs = readText(f.data); break;
      case HDR_TREE: hdr.tree = readText(f.data); break;
      case HDR_SAVE_TIME: hdr.saveTime = readTime(f.data); break;
      case HDR_SAVE_WHO: hdr.saveWho = readText(f.data); break;
      case HDR_SAVE_WHAT: hdr.saveWhat = readText(f.data); break;
      case HDR_SAVE_USER: hdr.saveUser = readText(f.data); break;
      case HDR_SAVE_HOST: hdr.saveHost = readText(f.data); break;
    }
  }
  return hdr;
}

function fieldsToRecord(fields) {
  const rec = { uuid: null, group: '', title: '', username: '', password: '', notes: '',
    url: '', email: '', autotype: '', runCmd: '', symbols: '', policyName: '',
    ctime: 0, pmtime: 0, atime: 0, exptime: 0, mtime: 0, protected: false,
    rawFields: [] };
  for (const f of fields) {
    rec.rawFields.push(f);
    switch (f.type) {
      case REC_UUID: rec.uuid = new Uint8Array(f.data); break;
      case REC_GROUP: rec.group = readText(f.data); break;
      case REC_TITLE: rec.title = readText(f.data); break;
      case REC_USER: rec.username = readText(f.data); break;
      case REC_PASSWORD: rec.password = readText(f.data); break;
      case REC_NOTES: rec.notes = readText(f.data); break;
      case REC_URL: rec.url = readText(f.data); break;
      case REC_EMAIL: rec.email = readText(f.data); break;
      case REC_AUTOTYPE: rec.autotype = readText(f.data); break;
      case REC_RUNCMD: rec.runCmd = readText(f.data); break;
      case REC_SYMBOLS: rec.symbols = readText(f.data); break;
      case REC_POLICYNAME: rec.policyName = readText(f.data); break;
      case REC_CTIME: rec.ctime = readTime(f.data); break;
      case REC_PMTIME: rec.pmtime = readTime(f.data); break;
      case REC_ATIME: rec.atime = readTime(f.data); break;
      case REC_EXPTIME: rec.exptime = readTime(f.data); break;
      case REC_MTIME: rec.mtime = readTime(f.data); break;
      case REC_PROTECTED: rec.protected = f.data.length > 0 && f.data[0] !== 0; break;
    }
  }
  return rec;
}

// Diagnostic logger - collects debug info during open
let debugLog = [];
function dbg(msg) { debugLog.push(msg); }
function hexBytes(arr, n) { return Array.from(arr.slice(0, n || arr.length)).map(b => b.toString(16).padStart(2,'0')).join(' '); }

async function openVault(fileData, password) {
  debugLog = [];
  const buf = new Uint8Array(fileData);
  dbg('File size: ' + buf.length + ' bytes');

  // File: [Header 152][Encrypted data N*16][HMAC 32]
  // The EOF marker "PWS3-EOFPWS3-EOF" is INSIDE the encrypted stream (last decrypted block)
  if (buf.length < 184) throw new Error('File too small (' + buf.length + ' bytes)');

  // Check tag
  const tagStr = String.fromCharCode(buf[0], buf[1], buf[2], buf[3]);
  dbg('Tag: "' + tagStr + '"');
  for (let i = 0; i < 4; i++) if (buf[i] !== TAG[i]) throw new Error('Not a valid .psafe3 file (tag: "' + tagStr + '")');

  const salt = buf.slice(4, 36);
  const iter = rU32(buf, 36);
  const storedHP = buf.slice(40, 72);
  const b1 = buf.slice(72, 88);
  const b2 = buf.slice(88, 104);
  const b3 = buf.slice(104, 120);
  const b4 = buf.slice(120, 136);
  const iv = buf.slice(136, 152);

  dbg('Iterations: ' + iter);
  dbg('Salt: ' + hexBytes(salt, 8) + '...');
  dbg('IV: ' + hexBytes(iv, 8) + '...');

  const encSize = buf.length - 184; // 152 header + 32 HMAC
  dbg('Encrypted data size: ' + encSize + ' bytes (' + (encSize/16) + ' blocks)');
  if (encSize < 16 || encSize % 16 !== 0) throw new Error('Invalid file structure (enc size ' + encSize + ' not multiple of 16)');

  const encData = buf.slice(152, 152 + encSize);
  const storedHMAC = buf.slice(buf.length - 32);
  dbg('Stored HMAC: ' + hexBytes(storedHMAC, 8) + '...');

  // Also check: could the file have a plaintext EOF marker? (old format interpretation)
  // Check bytes at file_size - 48 for "PWS3-EOFPWS3-EOF"
  let hasPlaintextEof = false;
  if (buf.length >= 200) {
    const possibleEof = buf.slice(buf.length - 48, buf.length - 32);
    hasPlaintextEof = true;
    for (let i = 0; i < 16; i++) {
      if (possibleEof[i] !== EOF_MARKER[i]) { hasPlaintextEof = false; break; }
    }
    dbg('Plaintext EOF at file_size-48: ' + (hasPlaintextEof ? 'YES' : 'no'));
  }

  // Stretch key
  dbg('Stretching key (' + iter + ' iterations)...');
  const pPrime = await stretchKey(password, salt, iter);
  dbg('P\' (stretched key): ' + hexBytes(pPrime, 8) + '...');

  // Verify password
  const hpCheck = await sha256(pPrime);
  dbg('SHA256(P\'): ' + hexBytes(hpCheck, 8) + '...');
  dbg('Stored H(P\'): ' + hexBytes(storedHP, 8) + '...');
  let pwMatch = true;
  for (let i = 0; i < 32; i++) {
    if (hpCheck[i] !== storedHP[i]) { pwMatch = false; break; }
  }
  if (!pwMatch) throw new Error('Incorrect password');
  dbg('Password verified OK');

  // Decrypt K and L using Twofish-ECB with P' as key
  const tfPrime = twofishInit(pPrime);
  const k1 = twofishDecryptBlock(b1, tfPrime);
  const k2 = twofishDecryptBlock(b2, tfPrime);
  const keyK = new Uint8Array(32);
  keyK.set(k1); keyK.set(k2, 16);

  const l1 = twofishDecryptBlock(b3, tfPrime);
  const l2 = twofishDecryptBlock(b4, tfPrime);
  const keyL = new Uint8Array(32);
  keyL.set(l1); keyL.set(l2, 16);

  dbg('Key K: ' + hexBytes(keyK, 8) + '...');
  dbg('Key L: ' + hexBytes(keyL, 8) + '...');

  // If plaintext EOF was detected, try the old layout: enc = file_size - 200
  let encDataToUse = encData;
  let storedHMACToUse = storedHMAC;
  let usePlaintextEof = false;

  if (hasPlaintextEof) {
    // Try with plaintext EOF layout first
    const encSizeAlt = buf.length - 200;
    if (encSizeAlt > 0 && encSizeAlt % 16 === 0) {
      dbg('Trying plaintext EOF layout (enc size ' + encSizeAlt + ')...');
      const tfK = twofishInit(keyK);
      const encDataAlt = buf.slice(152, 152 + encSizeAlt);
      const ptAlt = cbcDecrypt(encDataAlt, tfK, iv);
      // Check if first field looks valid
      if (ptAlt.length >= 5) {
        const firstLen = rU32(ptAlt, 0);
        const firstType = ptAlt[4];
        dbg('  Alt first field: len=' + firstLen + ' type=0x' + firstType.toString(16));
        if (firstLen < 10000 && firstType <= 0xFF) {
          encDataToUse = encDataAlt;
          storedHMACToUse = buf.slice(buf.length - 32);
          usePlaintextEof = true;
          dbg('  Using plaintext EOF layout');
        }
      }
    }
  }

  // Decrypt data with Twofish-CBC using K
  const tfK = twofishInit(keyK);
  const plaintext = cbcDecrypt(encDataToUse, tfK, iv);
  dbg('Decrypted data size: ' + plaintext.length + ' bytes');

  // Show first decrypted bytes (field header)
  if (plaintext.length >= 16) {
    dbg('First decrypted block: ' + hexBytes(plaintext, 16));
    const firstLen = rU32(plaintext, 0);
    const firstType = plaintext[4];
    dbg('First field: len=' + firstLen + ', type=0x' + firstType.toString(16));
  }

  // Show last decrypted block
  if (plaintext.length >= 16) {
    const lastBlock = plaintext.slice(plaintext.length - 16);
    dbg('Last decrypted block: ' + hexBytes(lastBlock, 16));
    const lastBlockStr = Array.from(lastBlock).map(b => b >= 32 && b < 127 ? String.fromCharCode(b) : '.').join('');
    dbg('Last block as text: "' + lastBlockStr + '"');
  }

  // Try to find EOF marker in decrypted data
  let eofOffset = -1;
  for (let off = plaintext.length - 16; off >= 0; off -= 16) {
    let match = true;
    for (let i = 0; i < 16; i++) {
      if (plaintext[off + i] !== EOF_MARKER[i]) { match = false; break; }
    }
    if (match) { eofOffset = off; break; }
  }
  dbg('EOF marker found at offset: ' + (eofOffset >= 0 ? eofOffset : 'NOT FOUND'));

  let fieldData;
  if (eofOffset >= 0) {
    fieldData = plaintext.slice(0, eofOffset);
  } else if (usePlaintextEof) {
    // Plaintext EOF layout - all decrypted data is field data
    fieldData = plaintext;
    dbg('Using all decrypted data as field data (plaintext EOF layout)');
  } else {
    // EOF not found - dump more info and throw
    dbg('--- SCANNING ALL BLOCKS ---');
    for (let off = 0; off < plaintext.length && off < 320; off += 16) {
      const block = plaintext.slice(off, off + 16);
      const asText = Array.from(block).map(b => b >= 32 && b < 127 ? String.fromCharCode(b) : '.').join('');
      dbg('  Block ' + (off/16) + ' @' + off + ': ' + hexBytes(block) + ' | ' + asText);
    }
    if (plaintext.length > 320) {
      dbg('  ... (' + ((plaintext.length - 320) / 16) + ' more blocks) ...');
      for (let off = plaintext.length - 64; off < plaintext.length; off += 16) {
        const block = plaintext.slice(off, off + 16);
        const asText = Array.from(block).map(b => b >= 32 && b < 127 ? String.fromCharCode(b) : '.').join('');
        dbg('  Block ' + (off/16) + ' @' + off + ': ' + hexBytes(block) + ' | ' + asText);
      }
    }
    throw new Error('EOF marker not found in decrypted data. See debug log below.');
  }

  dbg('Field data size: ' + fieldData.length + ' bytes');

  // Parse fields from decrypted data
  const allFields = parseFields(fieldData);
  dbg('Parsed ' + allFields.length + ' fields');

  // Log field types
  for (let i = 0; i < Math.min(allFields.length, 20); i++) {
    const f = allFields[i];
    let val = '';
    if (f.data.length <= 40) {
      try { val = ' = "' + new TextDecoder().decode(f.data).substring(0, 30) + '"'; } catch(e) {}
    }
    dbg('  Field ' + i + ': type=0x' + f.type.toString(16).padStart(2,'0') + ' len=' + f.data.length + val);
  }
  if (allFields.length > 20) dbg('  ... and ' + (allFields.length - 20) + ' more fields');

  // Compute HMAC over field data and verify
  let hmacLen = 0;
  for (const f of allFields) hmacLen += f.data.length;
  const hmacBuf = new Uint8Array(hmacLen);
  let hmacOff = 0;
  for (const f of allFields) {
    hmacBuf.set(f.data, hmacOff);
    hmacOff += f.data.length;
  }
  dbg('HMAC input size: ' + hmacLen + ' bytes');
  const computedHMAC = await hmacSha256(keyL, hmacBuf);
  dbg('Computed HMAC: ' + hexBytes(computedHMAC, 8) + '...');
  dbg('Stored HMAC:   ' + hexBytes(storedHMACToUse, 8) + '...');

  let hmacMatch = true;
  for (let i = 0; i < 32; i++) {
    if (computedHMAC[i] !== storedHMACToUse[i]) { hmacMatch = false; break; }
  }
  if (!hmacMatch) {
    dbg('HMAC MISMATCH');
    throw new Error('HMAC verification failed. See debug log below.');
  }
  dbg('HMAC verified OK');

  // Split into header and records
  let headerFields = [];
  const records = [];
  let current = [];
  let inHeader = true;

  for (const f of allFields) {
    if (f.type === HDR_END && inHeader) {
      headerFields = current;
      current = [];
      inHeader = false;
    } else if (f.type === REC_END && !inHeader) {
      records.push(fieldsToRecord(current));
      current = [];
    } else {
      current.push(f);
    }
  }

  dbg('Header fields: ' + headerFields.length + ', Records: ' + records.length);
  const header = fieldsToHeader(headerFields);
  return { header, records, iter };
}

// Serialize fields to binary
function serializeFields(header, records) {
  const enc = new TextEncoder();
  const allFieldData = []; // for HMAC
  const blocks = [];

  function addField(type, data) {
    allFieldData.push(data);
    const rawLen = 5 + data.length;
    const padLen = Math.ceil(rawLen / 16) * 16;
    const block = new Uint8Array(padLen);
    wU32(block, 0, data.length);
    block[4] = type;
    block.set(data, 5);
    // Fill padding with random bytes
    if (padLen > rawLen) {
      const pad = new Uint8Array(padLen - rawLen);
      crypto.getRandomValues(pad);
      block.set(pad, rawLen);
    }
    blocks.push(block);
  }

  function addTextField(type, text) { addField(type, enc.encode(text)); }
  function addTimeField(type, time) {
    const d = new Uint8Array(4);
    wU32(d, 0, time);
    addField(type, d);
  }
  function addEndField() { addField(0xFF, new Uint8Array(0)); }

  // Header fields
  const verData = new Uint8Array(2);
  verData[0] = header.version & 0xFF;
  verData[1] = (header.version >>> 8) & 0xFF;
  addField(HDR_VERSION, verData);
  if (header.uuid) addField(HDR_UUID, header.uuid);
  if (header.prefs) addTextField(HDR_PREFS, header.prefs);
  if (header.tree) addTextField(HDR_TREE, header.tree);
  addTimeField(HDR_SAVE_TIME, Math.floor(Date.now() / 1000));
  addTextField(HDR_SAVE_WHAT, 'Password Safe Web Client');
  if (header.dbName) addTextField(HDR_DB_NAME, header.dbName);
  if (header.dbDesc) addTextField(HDR_DB_DESC, header.dbDesc);
  addEndField();

  // Record fields
  for (const rec of records) {
    if (rec.uuid) addField(REC_UUID, rec.uuid);
    else { const u = new Uint8Array(16); crypto.getRandomValues(u); u[6]=(u[6]&0x0F)|0x40; u[8]=(u[8]&0x3F)|0x80; addField(REC_UUID, u); }
    if (rec.group) addTextField(REC_GROUP, rec.group);
    addTextField(REC_TITLE, rec.title || 'Untitled');
    if (rec.username) addTextField(REC_USER, rec.username);
    addTextField(REC_PASSWORD, rec.password || '');
    if (rec.notes) addTextField(REC_NOTES, rec.notes);
    if (rec.url) addTextField(REC_URL, rec.url);
    if (rec.email) addTextField(REC_EMAIL, rec.email);
    if (rec.ctime) addTimeField(REC_CTIME, rec.ctime);
    else addTimeField(REC_CTIME, Math.floor(Date.now() / 1000));
    addTimeField(REC_MTIME, Math.floor(Date.now() / 1000));
    if (rec.pmtime) addTimeField(REC_PMTIME, rec.pmtime);
    addEndField();
  }

  // Concat all blocks
  let totalLen = 0;
  for (const b of blocks) totalLen += b.length;
  const result = new Uint8Array(totalLen);
  let off = 0;
  for (const b of blocks) { result.set(b, off); off += b.length; }

  // HMAC data
  let hmacTotalLen = 0;
  for (const d of allFieldData) hmacTotalLen += d.length;
  const hmacBuf = new Uint8Array(hmacTotalLen);
  let hmacOff = 0;
  for (const d of allFieldData) { hmacBuf.set(d, hmacOff); hmacOff += d.length; }

  return { plaintext: result, hmacData: hmacBuf };
}

async function saveVault(header, records, password, iter) {
  iter = iter || 2048;
  const salt = new Uint8Array(32);
  crypto.getRandomValues(salt);

  const pPrime = await stretchKey(password, salt, iter);
  const hpPrime = await sha256(pPrime);

  // Generate random keys K and L
  const keyK = new Uint8Array(32);
  const keyL = new Uint8Array(32);
  crypto.getRandomValues(keyK);
  crypto.getRandomValues(keyL);

  // Encrypt K and L with Twofish-ECB using P'
  const tfPrime = twofishInit(pPrime);
  const b1 = twofishEncryptBlock(keyK.slice(0, 16), tfPrime);
  const b2 = twofishEncryptBlock(keyK.slice(16, 32), tfPrime);
  const b3 = twofishEncryptBlock(keyL.slice(0, 16), tfPrime);
  const b4 = twofishEncryptBlock(keyL.slice(16, 32), tfPrime);

  // Generate IV
  const iv = new Uint8Array(16);
  crypto.getRandomValues(iv);

  // Serialize fields
  const { plaintext, hmacData } = serializeFields(header, records);

  // Append EOF marker to plaintext (it gets encrypted inside the CBC stream)
  const ptWithEof = new Uint8Array(plaintext.length + 16);
  ptWithEof.set(plaintext);
  ptWithEof.set(EOF_MARKER, plaintext.length);

  // Encrypt with CBC (fields + EOF marker together)
  const tfK = twofishInit(keyK);
  const encrypted = cbcEncrypt(ptWithEof, tfK, iv);

  // Compute HMAC over field data only (not EOF marker)
  const hmac = await hmacSha256(keyL, hmacData);

  // Build file: [Header 152][Encrypted N*16][HMAC 32]
  const iterBuf = new Uint8Array(4);
  wU32(iterBuf, 0, iter);

  const fileSize = 152 + encrypted.length + 32;
  const file = new Uint8Array(fileSize);
  let off = 0;
  file.set(TAG, off); off += 4;
  file.set(salt, off); off += 32;
  file.set(iterBuf, off); off += 4;
  file.set(hpPrime, off); off += 32;
  file.set(b1, off); off += 16;
  file.set(b2, off); off += 16;
  file.set(b3, off); off += 16;
  file.set(b4, off); off += 16;
  file.set(iv, off); off += 16;
  file.set(encrypted, off); off += encrypted.length;
  file.set(hmac, off);

  return file;
}

// =====================================================================
// APPLICATION UI
// =====================================================================

let appState = {
  screen: 'open',
  vault: null,
  password: null,
  fileName: null,
  selectedIdx: -1,
  editing: false,
  modified: false
};

// DOM references
const $ = id => document.getElementById(id);
const screenOpen = $('screen-open');
const screenVault = $('screen-vault');
const fileInput = $('file-input');
const masterPw = $('master-password');
const btnOpen = $('btn-open');
const btnNew = $('btn-new');
const statusEl = $('status');
const searchBox = $('search-box');
const entryListEl = $('entry-list');
const entryDetailEl = $('entry-detail');
const vaultNameEl = $('vault-name');
const modalOverlay = $('modal-overlay');
const modalContent = $('modal-content');

let loadedFileData = null;

function showStatus(msg, cls) {
  statusEl.textContent = msg;
  statusEl.className = cls ? 'status-' + cls : '';
}

function showToast(msg) {
  const t = document.createElement('div');
  t.className = 'toast';
  t.textContent = msg;
  document.body.appendChild(t);
  setTimeout(() => t.remove(), 2000);
}

function showModal(html, onClose) {
  modalContent.innerHTML = html;
  modalOverlay.classList.remove('hidden');
  const closer = () => { modalOverlay.classList.add('hidden'); if (onClose) onClose(); };
  modalOverlay.onclick = e => { if (e.target === modalOverlay) closer(); };
  return closer;
}

function copyText(text) {
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(text).then(() => showToast('Copied')).catch(() => fallbackCopy(text));
  } else {
    fallbackCopy(text);
  }
}
function fallbackCopy(text) {
  const ta = document.createElement('textarea');
  ta.value = text;
  ta.style.cssText = 'position:fixed;left:-9999px';
  document.body.appendChild(ta);
  ta.select();
  document.execCommand('copy');
  document.body.removeChild(ta);
  showToast('Copied');
}

function formatTime(ts) {
  if (!ts) return '-';
  return new Date(ts * 1000).toLocaleString();
}

function uuidToHex(bytes) {
  if (!bytes) return '';
  return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
}

// File input handling
fileInput.addEventListener('change', () => {
  const file = fileInput.files[0];
  if (!file) return;
  appState.fileName = file.name;
  const reader = new FileReader();
  reader.onload = () => {
    loadedFileData = reader.result;
    btnOpen.disabled = false;
  };
  reader.readAsArrayBuffer(file);
});

masterPw.addEventListener('keydown', e => {
  if (e.key === 'Enter' && !btnOpen.disabled) btnOpen.click();
});

// Open vault
btnOpen.addEventListener('click', async () => {
  if (!loadedFileData || !masterPw.value) {
    showStatus('Please select a file and enter password', 'error');
    return;
  }
  showStatus('Decrypting vault...', 'info');
  btnOpen.disabled = true;
  try {
    // Run self-test first
    if (!twofishSelfTest()) {
      showStatus('Crypto self-test failed', 'error');
      btnOpen.disabled = false;
      return;
    }
    const vault = await openVault(loadedFileData, masterPw.value);
    appState.vault = vault;
    appState.password = masterPw.value;
    appState.modified = false;
    masterPw.value = '';
    showVaultScreen();
  } catch (e) {
    // Build debug log text
    const logText = debugLog.join('\n');
    // Show error + full debug log in a big visible box
    statusEl.innerHTML = '<div style="text-align:left">' +
      '<p style="color:#ef4444;font-weight:bold;margin-bottom:10px">' + escHtml(e.message) + '</p>' +
      (debugLog.length > 0 ?
        '<p style="font-size:12px;margin-bottom:6px;color:#666">Debug log (copy and share for troubleshooting):</p>' +
        '<textarea id="debug-log-area" readonly style="width:100%;height:250px;font-family:monospace;font-size:11px;padding:8px;border:1px solid #ccc;border-radius:6px;background:#1a1a2e;color:#e0e0e0;resize:vertical">' +
        escHtml(logText) + '</textarea>' +
        '<button onclick="document.getElementById(\'debug-log-area\').select();document.execCommand(\'copy\')" ' +
        'style="margin-top:6px;padding:4px 12px;font-size:12px;cursor:pointer;border:1px solid #ccc;border-radius:4px;background:#fff">Copy Log</button>'
      : '<p style="color:#999;font-size:12px">No debug log (you may be running an old version - refresh the page)</p>') +
      '</div>';
    statusEl.className = '';
    btnOpen.disabled = false;
  }
});

// New vault
btnNew.addEventListener('click', () => {
  const close = showModal(`
    <h3>Create New Vault</h3>
    <div class="form-group"><label>Vault Name</label><input type="text" id="new-vault-name" placeholder="My Vault"></div>
    <div class="form-group"><label>Master Password</label><input type="password" id="new-vault-pw" autocomplete="off"></div>
    <div class="form-group"><label>Confirm Password</label><input type="password" id="new-vault-pw2" autocomplete="off"></div>
    <div class="btn-row">
      <button class="btn btn-primary" id="new-vault-ok">Create</button>
      <button class="btn btn-secondary" id="new-vault-cancel">Cancel</button>
    </div>
    <div id="new-vault-err" style="color:#ef4444;font-size:13px;margin-top:8px"></div>
  `);

  $('new-vault-cancel').onclick = close;
  $('new-vault-ok').onclick = () => {
    const name = $('new-vault-name').value || 'My Vault';
    const pw = $('new-vault-pw').value;
    const pw2 = $('new-vault-pw2').value;
    if (!pw) { $('new-vault-err').textContent = 'Password required'; return; }
    if (pw !== pw2) { $('new-vault-err').textContent = 'Passwords do not match'; return; }
    const uuid = new Uint8Array(16);
    crypto.getRandomValues(uuid);
    uuid[6] = (uuid[6] & 0x0F) | 0x40;
    uuid[8] = (uuid[8] & 0x3F) | 0x80;
    appState.vault = {
      header: { version: 0x030D, uuid, dbName: name, dbDesc: '', prefs: '', tree: '',
        saveTime: 0, saveWho: '', saveWhat: '', saveUser: '', saveHost: '', rawFields: [] },
      records: [],
      iter: 2048
    };
    appState.password = pw;
    appState.fileName = name.replace(/[^a-zA-Z0-9]/g, '_') + '.psafe3';
    appState.modified = true;
    close();
    showVaultScreen();
  };
});

function showVaultScreen() {
  screenOpen.classList.add('hidden');
  screenVault.classList.remove('hidden');
  vaultNameEl.textContent = appState.vault.header.dbName || 'Vault';
  appState.selectedIdx = -1;
  appState.editing = false;
  searchBox.value = '';
  renderEntryList();
  renderDetail();
}

function showOpenScreen() {
  screenVault.classList.add('hidden');
  screenOpen.classList.remove('hidden');
  appState.vault = null;
  appState.password = null;
  loadedFileData = null;
  fileInput.value = '';
  btnOpen.disabled = true;
  showStatus('', '');
}

function getFilteredRecords() {
  const term = searchBox.value.toLowerCase();
  const recs = appState.vault.records;
  if (!term) return recs.map((r, i) => ({ rec: r, idx: i }));
  return recs.map((r, i) => ({ rec: r, idx: i }))
    .filter(({ rec }) =>
      (rec.title && rec.title.toLowerCase().includes(term)) ||
      (rec.username && rec.username.toLowerCase().includes(term)) ||
      (rec.group && rec.group.toLowerCase().includes(term)) ||
      (rec.url && rec.url.toLowerCase().includes(term)) ||
      (rec.email && rec.email.toLowerCase().includes(term)) ||
      (rec.notes && rec.notes.toLowerCase().includes(term))
    );
}

function renderEntryList() {
  const items = getFilteredRecords();
  // Group by group name
  const groups = {};
  for (const item of items) {
    const g = item.rec.group || '(No Group)';
    if (!groups[g]) groups[g] = [];
    groups[g].push(item);
  }
  const sortedGroups = Object.keys(groups).sort((a, b) => {
    if (a === '(No Group)') return 1;
    if (b === '(No Group)') return -1;
    return a.localeCompare(b);
  });

  let html = '';
  for (const g of sortedGroups) {
    html += `<div class="group-header">${escHtml(g)}</div>`;
    for (const item of groups[g].sort((a, b) => (a.rec.title || '').localeCompare(b.rec.title || ''))) {
      const active = item.idx === appState.selectedIdx ? ' active' : '';
      html += `<div class="entry-item${active}" data-idx="${item.idx}">
        <div class="entry-title">${escHtml(item.rec.title || 'Untitled')}</div>
        <div class="entry-user">${escHtml(item.rec.username || '')}</div>
      </div>`;
    }
  }
  if (!items.length) html = '<div style="padding:20px;color:#999;text-align:center">No entries found</div>';
  entryListEl.innerHTML = html;

  entryListEl.querySelectorAll('.entry-item').forEach(el => {
    el.addEventListener('click', () => {
      appState.selectedIdx = parseInt(el.dataset.idx);
      appState.editing = false;
      renderEntryList();
      renderDetail();
    });
  });
}

function renderDetail() {
  if (appState.selectedIdx < 0 || appState.selectedIdx >= appState.vault.records.length) {
    entryDetailEl.innerHTML = '<div class="empty-state">Select an entry or create a new one</div>';
    return;
  }

  const rec = appState.vault.records[appState.selectedIdx];
  const ed = appState.editing;
  const ro = ed ? '' : 'readonly';

  entryDetailEl.innerHTML = `
    <div class="detail-card">
      <h2>${ed ? 'Edit Entry' : escHtml(rec.title || 'Untitled')}</h2>
      <div class="field-row"><label>Title</label>
        <div class="field-value"><input type="text" id="f-title" value="${escAttr(rec.title)}" ${ro}></div>
      </div>
      <div class="field-row"><label>Group</label>
        <div class="field-value"><input type="text" id="f-group" value="${escAttr(rec.group)}" ${ro}></div>
      </div>
      <div class="field-row"><label>Username</label>
        <div class="field-value">
          <input type="text" id="f-user" value="${escAttr(rec.username)}" ${ro}>
          <button class="btn-icon" title="Copy" onclick="copyText(document.getElementById('f-user').value)">&#128203;</button>
        </div>
      </div>
      <div class="field-row"><label>Password</label>
        <div class="field-value">
          <input type="password" id="f-pass" class="password-field" value="${escAttr(rec.password)}" ${ro}>
          <button class="btn-icon" id="btn-toggle-pw" title="Show/Hide">&#128065;</button>
          <button class="btn-icon" title="Copy" onclick="copyText(document.getElementById('f-pass').value)">&#128203;</button>
        </div>
      </div>
      <div class="field-row"><label>URL</label>
        <div class="field-value">
          <input type="text" id="f-url" value="${escAttr(rec.url)}" ${ro}>
          <button class="btn-icon" title="Copy" onclick="copyText(document.getElementById('f-url').value)">&#128203;</button>
        </div>
      </div>
      <div class="field-row"><label>Email</label>
        <div class="field-value"><input type="text" id="f-email" value="${escAttr(rec.email)}" ${ro}></div>
      </div>
      <div class="field-row"><label>Notes</label>
        <textarea id="f-notes" ${ro}>${escHtml(rec.notes)}</textarea>
      </div>
      <div class="timestamp">Created: ${formatTime(rec.ctime)} | Modified: ${formatTime(rec.mtime)}</div>
      <div class="detail-actions">
        ${ed ? `
          <button class="btn btn-primary" id="btn-save-entry">Save</button>
          <button class="btn btn-secondary" id="btn-cancel-edit">Cancel</button>
          <button class="btn btn-danger" id="btn-delete-entry">Delete</button>
        ` : `
          <button class="btn btn-primary" id="btn-edit-entry">Edit</button>
          <button class="btn btn-danger" id="btn-delete-entry">Delete</button>
        `}
      </div>
    </div>
  `;

  // Toggle password visibility
  $('btn-toggle-pw').addEventListener('click', () => {
    const f = $('f-pass');
    f.type = f.type === 'password' ? 'text' : 'password';
  });

  if (ed) {
    $('btn-save-entry').addEventListener('click', () => {
      rec.title = $('f-title').value;
      rec.group = $('f-group').value;
      rec.username = $('f-user').value;
      rec.password = $('f-pass').value;
      rec.url = $('f-url').value;
      rec.email = $('f-email').value;
      rec.notes = $('f-notes').value;
      rec.mtime = Math.floor(Date.now() / 1000);
      if (!rec.pmtime && rec.password) rec.pmtime = rec.mtime;
      appState.editing = false;
      appState.modified = true;
      renderEntryList();
      renderDetail();
      showToast('Entry updated');
    });
    $('btn-cancel-edit').addEventListener('click', () => {
      appState.editing = false;
      renderDetail();
    });
  } else {
    $('btn-edit-entry').addEventListener('click', () => {
      appState.editing = true;
      renderDetail();
    });
  }

  $('btn-delete-entry').addEventListener('click', () => {
    const close = showModal(`
      <h3>Delete Entry?</h3>
      <p>Are you sure you want to delete "${escHtml(rec.title)}"?</p>
      <div class="btn-row" style="margin-top:20px">
        <button class="btn btn-danger" id="confirm-delete">Delete</button>
        <button class="btn btn-secondary" id="cancel-delete">Cancel</button>
      </div>
    `);
    $('cancel-delete').onclick = close;
    $('confirm-delete').onclick = () => {
      appState.vault.records.splice(appState.selectedIdx, 1);
      appState.selectedIdx = -1;
      appState.modified = true;
      close();
      renderEntryList();
      renderDetail();
      showToast('Entry deleted');
    };
  });
}

// Search
searchBox.addEventListener('input', () => {
  renderEntryList();
});

// Add new entry
$('btn-add').addEventListener('click', () => {
  const uuid = new Uint8Array(16);
  crypto.getRandomValues(uuid);
  uuid[6] = (uuid[6] & 0x0F) | 0x40;
  uuid[8] = (uuid[8] & 0x3F) | 0x80;
  const newRec = {
    uuid, group: '', title: 'New Entry', username: '', password: '', notes: '',
    url: '', email: '', autotype: '', runCmd: '', symbols: '', policyName: '',
    ctime: Math.floor(Date.now() / 1000), pmtime: 0, atime: 0, exptime: 0,
    mtime: Math.floor(Date.now() / 1000), protected: false, rawFields: []
  };
  appState.vault.records.push(newRec);
  appState.selectedIdx = appState.vault.records.length - 1;
  appState.editing = true;
  appState.modified = true;
  renderEntryList();
  renderDetail();
});

// Save vault
$('btn-save').addEventListener('click', async () => {
  if (!appState.vault || !appState.password) return;
  try {
    showToast('Saving...');
    const fileData = await saveVault(
      appState.vault.header,
      appState.vault.records,
      appState.password,
      appState.vault.iter
    );
    const blob = new Blob([fileData], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = appState.fileName || 'vault.psafe3';
    a.click();
    URL.revokeObjectURL(url);
    appState.modified = false;
    showToast('Vault saved');
  } catch (e) {
    showToast('Save failed: ' + e.message);
  }
});

// Lock vault
$('btn-lock').addEventListener('click', () => {
  if (appState.modified) {
    const close = showModal(`
      <h3>Unsaved Changes</h3>
      <p>You have unsaved changes. Lock anyway?</p>
      <div class="btn-row" style="margin-top:20px">
        <button class="btn btn-danger" id="confirm-lock">Lock</button>
        <button class="btn btn-secondary" id="cancel-lock">Cancel</button>
      </div>
    `);
    $('cancel-lock').onclick = close;
    $('confirm-lock').onclick = () => { close(); showOpenScreen(); };
  } else {
    showOpenScreen();
  }
});

// HTML escaping helpers
function escHtml(s) { return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }
function escAttr(s) { return String(s||'').replace(/&/g,'&amp;').replace(/"/g,'&quot;').replace(/'/g,'&#39;'); }

// =====================================================================
// INITIALIZATION
// =====================================================================

(function init() {
  if (!twofishSelfTest()) {
    showStatus('CRITICAL: Twofish self-test failed. This browser may not be supported.', 'error');
    btnOpen.disabled = true;
    btnNew.disabled = true;
  }
})();

</script>
</body>
</html>
